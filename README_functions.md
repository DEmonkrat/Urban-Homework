# Urban-Homework
My homeworks on Urban University learning
## Задача 1 (Task 1)
Напишите функцию высшего порядка, которая получает в качестве аргумента две функции первого порядка:
* Функцию для преобразования текста сообщения в верхний регистр.
* Функцию для преобразования текста сообщения в нижний регистр.
___

## Задача 2 (Task 2)
Часто при разработке и работе с рассылками писем (e-mail) они отправляются от одного и того же пользователя(администрации или службы поддержки). Тем не менее должна быть возможность сменить его в редких случаях. \
Создайте функцию **send_email**, которая принимает 2 обычных аргумента: сообщение и получатель и 1 обязательно именованный аргумент со значением по умолчанию - отправитель.\
Внутри функции реализовать следующую логику:
* Проверка на корректность e-mail отправителя и получателя.
* Проверка на отправку самому себе.
* Проверка на отправителя по умолчанию.
#### Пункты задачи:
1. Создайте функцию **send_email**, которая принимает 2 обычных аргумента: **message** (сообщение), **recipient** (получатель) и 1 обязательно именованный аргумент со значением по умолчанию **sender = "university.help@gmail.com"**.
2. Если строки **recipient** и **sender** не содержит **"@"** или не оканчивается на **".com"**, **".ru"**, **".net"**, то вывести на экран(в консоль) строку: "_Невозможно отправить письмо с адреса_ <**sender**> на адрес <**recipient**>".
3. Если же **sender** и **recipient** совпадают, то вывести "_Нельзя отправить письмо самому себе!_"
4. Если же отправитель по умолчанию - **university.help@gmail.com**, то вывести сообщение: "_Письмо успешно отправлено с адреса_ <**sender**> _на адрес_ <**recipient**>."
5. В противном случае вывести сообщение: "_НЕСТАНДАРТНЫЙ ОТПРАВИТЕЛЬ! Письмо отправлено с адреса_ <**sender**> _на адрес_ <**recipient**>."
6. За один вызов функции выводится **только одно** и перечисленных уведомлений! Проверки перечислены по мере выполнения.
___

## Задача 3 (Task 3) 
### Фукнции. Запаковка и распаковка параметров
Задача "Распаковка":\
**Функция с параметрами по умолчанию:**
1. Создайте функцию **print_params**(a = 1, b = 'строка', c = True), которая принимает три параметра со значениями по умолчанию (например сейчас это: **1, 'строка', True**).
2. Функция должна выводить эти параметры.
3. Вызовите функцию **print_params** с разным количеством аргументов, включая вызов без аргументов.
4. Проверьте, работают ли вызовы **print_params**(b = 25) **print_params**(c = [1,2,3])

**Распаковка параметров:**

1. Создайте список **values_list** с тремя элементами разных типов.
2. Создайте словарь **values_dict** с тремя ключами, соответствующими параметрам функции **print_params**, и значениями разных типов.
3. Передайте **values_list** и **values_dict** в функцию **print_params**, используя распаковку параметров (* для списка и ** для словаря).

**Распаковка + отдельные параметры:**

1. Создайте список **values_list_2** с двумя элементами разных типов
2. Проверьте, работает ли **print_params**(*values_list_2, 42)

**Пример результата выполнения программы:**  
Исходный код:
> values_list_2 = [54.32, 'Строка' ]\
>print_params(*values_list_2, 42) 
> 
Вывод на консоль:
>54.32 'Строка' 42
___

## Задача 4 (Task 4)
**Задача "Однокоренные":**\
Напишите функцию **single_root_words**, которая принимает одно обязательное слово в 
параметр **root_word**, а далее неограниченную последовательность в 
параметр *other_words.

Функция должна составить новый список **same_words** только из тех слов списка **other_words**, которые содержат **root_word** или наоборот **root_word** содержит одно из этих слов. После вернуть список **same_words** в качестве результата своей работы.

**Пункты задачи:**\
1. Объявите функцию **single_root_words** и напишите в ней параметры **root_word** и ***other_words**.
2. Создайте внутри функции пустой список **same_words**, который пополнится нужными словами.
3. При помощи цикла **for** переберите предполагаемо подходящие слова.
4. Пропишите корректное относительно задачи условие, при котором добавляются слова в результирующий список **same_words**.
5. После цикла верните образованный функцией список same_words.
6. Вызовите функцию **single_root_words** и выведете на экран(консоль) возвращённое ей значение.
7. Пример результата выполнения программы:

  **Исходный код:**  
> result1 = single_root_words('rich', 'richiest', 'orichalcum', 'cheers', 'richies')  
result2 = single_root_words('Disablement', 'Able', 'Mable', 'Disable', 'Bagel')  
print(result1)  
print(result2)

  **Вывод на консоль:**
> ['richiest', 'orichalcum', 'richies']  
['Able', 'Disable']

**Примечания:**
При проверке наличия одного слова в составе другого стоит учесть, что регистр символов не должен влиять ни на что. (**'Disablement' - 'Able'**) (**'Able', 'able', 'AbLe'** - все подходят)
___

<img src="https://mdg.imgix.net/assets/images/san-juan-mountains.jpg" width="400" height="300">

___
## Задача 5 (Task 5) 
### "Раз, два, три, четыре, пять .... Это не всё?":
Наши студенты, без исключения, - очень умные ребята. Настолько умные, 
что иногда по утру сами путаются в том, что намудрили вчера вечером.  
Один из таких учеников уснул на клавиатуре в процессе упорной учёбы 
(ещё и трудолюбивые). Тем не менее, даже после сна, его код остался рабочим и 
выглядел следующим образом:  
> **data_structure = [  
  [1, 2, 3],  
  {'a': 4, 'b': 5},  
  (6, {'cube': 7, 'drum': 8}),  
  "Hello",  
  ((), [{(2, 'Urban', ('Urban2', 35))}])  
]**

Увидев это студент задался вопросом: "А есть ли универсальное решение для 
подсчёта суммы всех чисел и длин всех строк?"  
Да, выглядит страшно, да и обращаться нужно к каждой внутренней структуре 
(списку, словарю и т.д.) по-разному.  
Ученику пришлось каждый раз использовать индексацию и обращение по 
ключам - универсального решения для таких структур он не нашёл.  

**Помогите сокурснику осуществить его задумку.**  
Что должно быть подсчитано:  
* Все числа (не важно, являются они ключами или значениям или ещё чем-то).
* Размеры всех строк (не важно, являются они ключами или значениям или ещё чем-то)  

Для примера, указанного выше, расчёт вёлся следующим образом:  
1 + 2 + 3 + len('a') + 4 + len('b') + 5 + 6 + len('cube') + 7 + .... + 35 = 99

___

## Задача 6 (Task 6) Urban
### "А как делить?":

В школе нам говорили, что на 0 делить нельзя. Высшая же математика опровергает это и 
говорит, что результат при делении на 0 будет стремиться к бесконечности.  
Давайте реализуем оба способа, чтобы у вас всегда был выбор!  
Создайте модули **fake_math** и **true_math** в которых создайте функции отвечающие 
за деление, но разными способами.  
В **fake_math** создайте функцию **divide**, которая принимает два параметра **first** 
и **second**. Функция должна возвращать результат деления **first** на **second**, но 
когда в second записан 0 - возвращать строку **'Ошибка'**.  
В **true_math** создайте функцию **divide**, которая принимает два параметра **first** 
и **second**. 
Функция должна возвращать результат деления **first** на **second**, но когда в 
second записан 0 - возвращать **бесконечность**.  
Бесконечность можно импортировать из встроенной библиотеки **math** (_from math import
inf_)  
**Пункты задачи:**
* Создайте модули **fake_math** и **true_math**.
* Напишите функции **divide** в обоих методах. Разница между этими функциями - 
возвращаемое значение.
* Создайте модуль **module_4_1** (если ещё не создан), импортируйте в него 
функции **divide** из модулей **fake_math** и **true_math**, назвав их разными 
именами на своё усмотрение, чтобы не было конфликтов имён, при помощи оператора **as**.
* Запустите эти функции в модуле **module_4_1**, передав первым аргументом 
произвольное число отличное от 0, вторым аргументом - 0
* Выведи результаты вызовов этих функций на экран(в консоль).
___

## Задача 7 (Task 7) Urban
### "Developer - не только разработчик":  
Файл **module_5_1.py**   
Реализуйте класс **House**, объекты которого будут создаваться следующим образом:
* House('ЖК Эльбрус', 30)      

Объект этого класса должен обладать следующими атрибутами:
* **self.name** - имя, **self.number_of_floors** - кол-во этажей

Также должен обладать методом **go_to(new_floor)**, где **new_floor** - номер этажа(int), на который нужно приехать.  
Метод **go_to** выводит на экран(в консоль) значения от 1 до **new_floor**(включительно).  
Если же **new_floor** больше чем **self.number_of_floors** или меньше **1**, то вывести строку **"Такого этажа не существует"**.

Пункты задачи:
* Создайте класс House.
* Внутри класса House определите метод  **\_\_init__**, в который передадите название и кол-во этажей.
* Внутри метода **\_\_init__** создайте атрибуты объекта **self.name** и **self.number_of_floors**, присвойте им переданные значения.
* Создайте метод **go_to** с параметром **new_floor** и напишите логику внутри него на основе описания задачи.
* Создайте объект класса **House** с произвольным названием и количеством этажей.
* Вызовите метод **go_to** у этого объекта с произвольным числом.

## Задача 8 (Task 8) Urban HARD
**Задание "Свой YouTube":**  
Университет Urban подумывает о создании своей платформы, где будут размещаться дополнительные полезные ролики на тему IT (юмористические, интервью и т.д.). Конечно же для старта написания интернет ресурса требуются хотя бы базовые знания программирования.  
Именно вам выпала возможность продемонстрировать их, написав небольшой набор классов, которые будут выполнять похожий функционал на сайте.   
Всего будет 3 класса: **UrTube, Video, User.**

**Общее ТЗ:**   
Реализовать классы для взаимодействия с платформой, каждый из которых будет содержать методы добавления видео, авторизации и регистрации пользователя и т.д.

**Подробное ТЗ:**  
Каждый объект класса **User** должен обладать следующими атрибутами и методами:
* Атрибуты: **nickname**(имя пользователя, строка), **password**(в хэшированном виде, число), **age**(возраст, число)

Каждый объект класса **Video** должен обладать следующими атрибутами и методами:
* Атрибуты: **title**(заголовок, строка), **duration**(продолжительность, секунды), **time_now**(секунда остановки (изначально 0)), **adult_mode**(ограничение по возрасту, **bool** (**False** по умолчанию))

Каждый объект класса **UrTube** должен обладать следующими атрибутами и методами:
1. Атрибуты: **users**(список объектов User), **videos**(список объектов Video), **current_user**(текущий пользователь, User)
2. Метод **log_in**, который принимает на вход аргументы: **nickname**, **password** и пытается найти пользователя в **users** с такими же логином и паролем. Если такой пользователь существует, то **current_user** меняется на найденного. Помните, что **password** передаётся в виде строки, а сравнивается по хэшу.
3. Метод **register**, который принимает три аргумента: **nickname, password, age,** и добавляет пользователя в список, если пользователя не существует (с таким же **nickname**). Если существует, выводит на экран: "Пользователь {nickname} уже существует". После регистрации, вход выполняется автоматически.
4. Метод **log_out** для сброса текущего пользователя на **None**.
5. Метод **add**, который принимает неограниченное кол-во объектов класса **Video** и все добавляет в **videos**, если с таким же названием видео ещё не существует. В противном случае ничего не происходит.
6. Метод **get_videos**, который принимает поисковое слово и возвращает список названий всех видео, содержащих поисковое слово. Следует учесть, что слово 'UrbaN' присутствует в строке **'Urban the best'** (не учитывать регистр).
7. Метод **watch_video**, который принимает название фильма, если не находит точного совпадения(вплоть до пробела), то ничего не воспроизводится, если же находит - ведётся отчёт в консоль на какой секунде ведётся просмотр. После текущее время просмотра данного видео сбрасывается.

Для метода **watch_video** так же учитывайте следующие особенности:
1. Для паузы между выводами секунд воспроизведения можно использовать функцию **sleep** из модуля **time**.
2. Воспроизводить видео можно только тогда, когда пользователь вошёл в **UrTube**. В противном случае выводить в консоль надпись: "Войдите в аккаунт, чтобы смотреть видео"
3. Если видео найдено, следует учесть, что пользователю может быть отказано в просмотре, т.к. есть ограничения 18+. Должно выводиться сообщение: "Вам нет 18 лет, пожалуйста покиньте страницу"
4. После воспроизведения нужно выводить: "Конец видео"

Примечания:
* Не забывайте для удобства использовать **dunder**(магические) методы: **\_\_str__, \_\_repr__, \_\_contains__, \_\_eq__** и др. (повторить можно здесь)
* Чтобы не запутаться, рекомендуется после реализации каждого метода проверять как он работает, тестировать разные вариации.

# Наследование классов
## Задача 9 (Task 6.1) Urban 
**Задача "Съедобное, несъедобное":**
Разнообразие животного мира давно будоражит умы человечества. Царства, классы, виды... Почему бы и нам не попробовать выстроить что-то подобное используя наследования классов?  
Необходимо описать пример иерархии животного мира, используя классы и принцип наследования.  
**Создайте:**
* 2 класса родителя: **Animal, Plant**

Для класса **Animal** атрибуты **alive = True(живой)** и **fed = False(накормленный)**, **name** - индивидуальное название каждого животного.   
Для класса **Plant** атрибут **edible = False(съедобность)**, **name** - индивидуальное название каждого растения

* 4 класса наследника:

* **Mammal, Predator** для **Animal**.
* **Flower, Fruit** для **Plant**.

У каждого из объектов класса **Mammal** и **Predator** должны быть атрибуты и методы:
* **eat(self, food)** - метод, где **food** - это параметр, принимающий объекты классов растений.

Метод **eat** должен работать следующим образом:
* Если переданное растение (**food**) съедобное - выводит на экран **"<self.name> съел <food.name>"**, меняется атрибут **fed** на **True**.
* Если переданное растение (**food**) не съедобное - выводит на экран **"<self.name> не стал есть <food.name>"**, меняется атрибут **alive** на **False**.

Т.е если животному дать съедобное растение, то животное насытится, если не съедобное - погибнет.  
У каждого объекта **Fruit** должен быть атрибут **edible = True** (переопределить при наследовании).  
Создайте объекты классов и проделайте действия затронутые в примере результата работы программы.  
Пункты задачи:
1. Создайте классы Animal и Plant с соответствующими атрибутами и методами
2. Создайте(+унаследуйте) классы Mammal, Predator, Flower, Fruit с соответствующими атрибутами и методами. При необходимости переопределите значения атрибутов.
3. Создайте объекты этих классов.

## Задача 10 (Task 6.2) Urban 
**Задача "Изменять нельзя получать":**

В этой задаче мы реализуем классы транспорта, в которых нельзя будет просто так 
поменять цвет, мощность двигателя и прочие свойства, т.к. в реальной жизни это 
чаще всего делается не владельцем, а в специальных сервисах. Да, узнать значения 
этих свойств мы сможем, но вот изменить - нет.  
Вам необходимо создать 2 класса: **Vehicle** и **Sedan**, где **Vehicle** - это 
любой транспорт, а **Sedan(седан)** - наследник класса **Vehicle**.   
**I.** Каждый объект **Vehicle** должен содержать следующие атрибуты объекта:
1. Атрибут **owner(str)** - владелец транспорта. (владелец может меняться)
2. Атрибут **__model(str)** - модель (марка) транспорта. (мы не можем менять название модели)
3. Атрибут **__engine_power(int**) - мощность двигателя. (мы не можем менять мощность двигателя самостоятельно)
4. Атрибут **__color(str)** - название цвета. (мы не можем менять цвет автомобиля своими руками)

А так же атрибут класса:  
1. Атрибут класса **__COLOR_VARIANTS**, в который записан список допустимых цветов для окрашивания. (Цвета написать свои)

Каждый объект **Vehicle** должен содержать следующий методы:
1. Метод **get_model** - возвращает строку: *\"Модель: <название модели транспорта>"*
2. Метод **get_horsepower** - возвращает строку: *\"Мощность двигателя: <мощность>"*
3. Метод **get_color** - возвращает строку: *\"Цвет: <цвет транспорта>"*
4. Метод **print_info** - распечатывает результаты методов (в том же порядке): **get_model, get_horsepower, get_color**; а так же владельца в конце в формате *\"Владелец: <имя>"*
5. Метод **set_color** - принимает аргумент **new_color(str)**, меняет цвет **__color** на **new_color**, если он есть в списке **__COLOR_VARIANTS**, в противном случае выводит на экран надпись: *\"Нельзя сменить цвет на <новый цвет>".*

Взаимосвязь методов и скрытых атрибутов:
* Методы **get_model, get_horsepower, get_color** находятся в одном классе с соответствующими им атрибутами: **__model, __engine_power, __color**. Поэтому атрибуты будут доступны для методов.
* Атрибут класса **__COLOR_VARIANTS** можно получить обращаясь к нему через объект**(self)**.
* Проверка в **__COLOR_VARIANTS** происходит не учитывая регистр ('BLACK' ~ 'black').

**II.** Класс **Sedan** наследуется от класса **Vehicle**, а так же содержит следующие атрибуты:
* Атрибут **__PASSENGERS_LIMIT = 5** (в седан может поместиться только 5 пассажиров)

Пункты задачи:
* Создайте классы **Vehicle** и **Sedan**.
* Напишите соответствующие свойства в обоих классах.
* Не забудьте сделать **Sedan** наследником класса **Vehicle**.
* Создайте объект класса **Sedan** и проверьте, как работают все его методы, взяты из класса **Vehicle**.

## Задача 11 (Task 6.3) Urban 
**Задача "Ошибка эволюции":**

Замечали, что некоторые животные в нашем мире обладают странными и, порой, несовместимыми друг с другом свойствами? Например, утконос... Вроде есть клюв, но не птица. Вроде милый, а есть шипы на задних лапах. А ещё он откладывает яйца... Опустим факт о том, что они потеют молоком и попробуем не эволюционным способом создать нашего утконоса.  

Необходимо написать 5 классов:
* **Animal** - класс описывающий животных.

**Класс** обладает следующими атрибутами:
* **live = True**
* **sound = None** - звук (изначально отсутствует)
* **_DEGREE_OF_DANGER = 0** - степень опасности существа

**Объект этого класса** обладает следующими атрибутами:
* **_cords = [0, 0, 0]** - координаты в пространстве.
* **speed =** ... - скорость передвижения существа (определяется при создании объекта)

И методами:
* **move(self, dx, dy, dz)**, который должен менять соответствующие кооординаты в **_cords** на dx, dy и dz в том же порядке, где множетелем будет являтся **speed**. 
Если при попытке изменения координаты z в **_cords** значение будет меньше 0, то выводить сообщение *\"It's too deep, i can't dive :("* , при этом изменения не вносяться.
* **get_cords(self)**, который выводит координаты в формате: "X: <координаты по x>, Y: <координаты по y>, Z: <координаты по z>"
* **attack(self)**, который выводит *\"Sorry, i'm peaceful :)"*, если степень опасности меньше 5 и *\"Be careful, i'm attacking you 0_0"* , если больше.
* **speak(self)**, который выводит строку со звуком **sound**.

**Bird** - класс описывающий птиц. Наследуется от **Animal**.  
Должен обладать атрибутом:
* **beak = True** - наличие клюва

И методом:
* **lay_eggs(self)**, который выводит строку *\"Here are(is) <случайное число от 1 до 4> eggs for you"*

**AquaticAnimal** - класс описывающий плавающего животного. Наследуется от **Animal**.  
В этом классе атрибут **_DEGREE_OF_DANGER = 3**.  
Должен обладать методом:
* **dive_in(self, dz)** - где dz изменение координаты z в **_cords**. Должен изменять в отрицательную сторону координату z уменьшенную в 2 раза с учётом скорости. С каким бы знаком не был передан параметр dz, внутри метода используйте его значение по модулю (функция abs).

**PoisonousAnimal** - класс описывающий ядовитых животных. Наследуется от **Animal**.  
В этом классе атрибут **_DEGREE_OF_DANGER = 8**.

**Duckbill** - класс описывающий утконоса. Наследуется от классов **Bird, AquaticAnimal, PoisonousAnimal**. Порядок наследования определите сами, опираясь на ниже приведённые примеры выполнения кода.  
Объект этого класса должен обладать одним дополнительным атрибутом:
* **sound = "Click-click-click"** - звук, который издаёт утконос

По итогу мы должны получить живого утконоса с клювом, атакующего и издающего странные звуки.
После чего утконос совершает манёвры и ныряет.  
Теперь утконос в безопасности, он откладывает яйца для будущего потомства.

Примечания:
1. Будьте внимательней, когда вызываете методы классов родителей в классе наследнике при множественном наследовании: при обращении через super() методы будут искаться сначала в первом, потом во втором и т.д. классах по mro().
2. При определении порядка наследования обратите внимание на то, что утконос атакует "Be careful, i'm attacking you 0_0"

## Задача 12 (Task 6.4 hard) Urban 
**Задание "Они все так похожи":**

2D? 3D? Даже 4D?.... Настолько глубоко мы заходить конечно же не будем, 4D подождёт, но вот с двумерными и трёхмерными фигурами можем поэкспериментировать.
Вы когда-нибудь задумывались как устроены графические библиотеки для языков программирования?  
Безусловно, там выполняются огромные расчёты при помощи вашей видеокарты, но... Что лежит в основе удобного использования таких объектов?  
По названию задачи можно понять, что все геометрические фигуры обладают схожими свойствами, такими как: длины сторон, цвет и др.  
Давайте попробуем реализовать простейшие классы для некоторых таких фигур и при этом применить наследование (в будущем, изучая сторонние библиотеки, вы будете замечать схожие классы, уже написанные кем-то ранее):

**Общее ТЗ:**
* Реализовать классы **Figure**(родительский), **Circle, Triangle** и **Cube**, объекты которых будут обладать методами изменения размеров, цвета и т.д.

Многие атрибуты и методы должны быть инкапсулированны и для них должны быть написаны интерфейсы взаимодействия (методы) - геттеры и сеттеры.

Подробное ТЗ:  

Атрибуты **класса Figure**:
* **sides_count = 0**

Каждый объект класса **Figure** должен обладать следующими атрибутами:
1. Атрибуты(инкапсулированные): **__sides**(список сторон (целые числа)), **__color**(список цветов в формате RGB)
2. Атрибуты(публичные): **filled**(закрашенный, bool)

И методами:
1. Метод **get_color**, возвращает список RGB цветов.
2. Метод **__is_valid_color** - служебный, принимает параметры r, g, b, который проверяет корректность переданных значений перед установкой нового цвета. Корректный цвет: все значения r, g и b - целые числа в диапазоне от 0 до 255 (включительно).
4. Метод **set_color** принимает параметры r, g, b - числа и изменяет атрибут **__color** на соответствующие значения, предварительно проверив их на корректность. Если введены некорректные данные, то цвет остаётся прежним.
5. Метод **__is_valid_sides** - служебный, принимает неограниченное кол-во сторон, возвращает **True** если все стороны целые положительные числа и кол-во новых сторон совпадает с текущим, **False** - во всех остальных случаях.
6. Метод **get_sides** должен возвращать значение я атрибута **__sides**.
7. Метод **__len__** должен возвращать периметр фигуры.
8. Метод **set_sides(self, *new_sides)** должен принимать новые стороны, если их количество не равно **sides_count**, то не изменять, в противном случае - менять.

Атрибуты **класса Circle**:
* **sides_count = 1**

Каждый объект класса **Circle** должен обладать следующими атрибутами и методами:
1. Все атрибуты и методы класса **Figure**
2. Атрибут **__radius**, рассчитать исходя из длины окружности (одной единственной стороны).
3. Метод **get_square** возвращает площадь круга (можно рассчитать как через длину, так и через радиус).

Атрибуты **класса Triangle**:
* **sides_count = 3**

Каждый объект класса **Triangle** должен обладать следующими атрибутами и методами:
1. Все атрибуты и методы класса **Figure**
2. Метод **get_square** возвращает площадь треугольника. (можно рассчитать по формуле Герона)

Атрибуты **класса Cube**:
* **sides_count = 12**

Каждый объект класса **Cube** должен обладать следующими атрибутами и методами:
1. Все атрибуты и методы класса **Figure**.
2. Переопределить **__sides** сделав список из 12 одинаковы сторон (передаётся 1 сторона)
3. Метод **get_volume**, возвращает объём куба.

**ВАЖНО!**  
При создании объектов делайте проверку на количество переданных сторон, если сторон не ровно sides_count, то создать массив с единичными сторонами и в том кол-ве, которое требует фигура.

**Примеры.**  
Пример 1: Circle((200, 200, 100), 10, 15, 6), т.к. сторона у круга всего 1, то его стороны будут - [1]

Пример 2: Triangle((200, 200, 100), 10, 6), т.к. сторон у треугольника 3, то его стороны будут - [1, 1, 1]

Пример 3: Cube((200, 200, 100), 9), т.к. сторон(рёбер) у куба - 12, то его стороны будут - [9, 9, 9, ....., 9] (12)

Пример 4: Cube((200, 200, 100), 9, 12), т.к. сторон(рёбер) у куба - 12, то его стороны будут - [1, 1, 1, ....., 1]

**Примечания (рекомендации)**:
1. Рекомендуется сделать дополнительные (свои проверки) работы методов объектов каждого класса.
2. Делайте каждый класс и метод последовательно и проверяйте работу каждой части отдельно.
3. Для проверки принадлежности к типу рекомендуется использовать функцию **isinstance**.
4. Помните, служебные инкапсулированные методы можно и нужно использовать только внутри текущего класса.
5. Вам не запрещается вводить дополнительные атрибуты и методы, **творите, но не переборщите!**

## Задача 13 (Task 7.1) Urban 
**Учёт товаров**
Необходимо реализовать 2 класса **Product** и **Shop**, с помощью которых будет 
производиться запись в файл с продуктами.

Объекты класса **Product** будут создаваться следующим 
образом - **Product('Potato', 50.0, 'Vagetables')** и обладать следующими свойствами:
1. Атрибут **name** - название продукта (строка).
2. Атрибут **weight** - общий вес товара (дробное число) (5.4, 52.8 и т.п.).
3. Атрибут **category** - категория товара (строка).
4. Метод **\_\_str__**, который возвращает строку в формате **'<название>, <вес>, 
<категория>'**. Все данные в строке разделены запятой с пробелами.

Объекты класса **Shop** будут создаваться следующим 
образом - **Shop()** и обладать следующими свойствами:
1. Инкапсулированный атрибут **__file_name = 'products.txt'**.
2. Метод **get_products(self)**, который считывает всю информацию из 
файла **__file_name**, закрывает его и возвращает единую строку со всеми товарами 
из файла **__file_name**.
3. Метод **add(self, *products)**, который принимает неограниченное 
количество объектов класса Product. Добавляет в файл **__file_name** каждый 
продукт из products, если его ещё нет в файле (по названию). Если такой продукт 
уже есть, то не добавляет и выводит строку _'Продукт <название> уже есть в магазине'_.

## Задача 14 (Task 7.3) Urban 
**Задача "Найдёт везде":**

Напишите класс **WordsFinder**, объекты которого создаются следующим образом:
* **WordsFinder('file1.txt, file2.txt', 'file3.txt', ...)**.

Объект этого класса должен принимать при создании неограниченного количество названий файлов и записывать их в атрибут **file_names** в виде списка или кортежа.  
Также объект класса **WordsFinder** должен обладать следующими методами:
* **get_all_words** - подготовительный метод, который возвращает словарь следующего вида:
**{'file1.txt': ['word1', 'word2'], 'file2.txt': ['word3', 'word4'], 'file3.txt': ['word5', 'word6', 'word7']}**

Где:
* 'file1.txt', 'file2.txt', ''file3.txt'' - названия файлов.
* ['word1', 'word2'], ['word3', 'word4'], ['word5', 'word6', 'word7'] - слова содержащиеся в этом файле.

Алгоритм получения словаря такого вида в методе **get_all_words**:
1. Создайте пустой словарь **all_words**.
2. Переберите названия файлов и открывайте каждый из них, используя оператор **with**.
3. Для каждого файла считывайте единые строки, переводя их в нижний регистр (метод **lower()**).
4. Избавьтесь от пунктуации **[',', '.', '=', '!', '?', ';', ':', ' - ']** в строке. (тире обособлено пробелами, это не дефис в слове).
5. Разбейте эту строку на элементы списка методом split(). (разбивается по умолчанию по пробелу)
6. В словарь **all_words** запишите полученные данные, ключ - название файла, значение - список из слов этого файла.

Напишите также дополнительные методы для класса **WordsFinder**:
* **find(self, word)** - метод, где word - искомое слово. Возвращает словарь, где ключ - название файла, значение - позиция первого такого слова в списке слов этого файла.
* **count(self, word)** - метод, где word - искомое слово. Возвращает словарь, где ключ - название файла, значение - количество слова word в списке слов этого файла.

В методах **find** и **count** пользуйтесь ранее написанным методом **get_all_words** для получения названия файла и списка его слов.

Для удобного перебора одновременно ключа(названия) и значения(списка слов) можно воспользоваться методом словаря - **item()**.
=======

## Задача 15 (Task 7.4,5) Urban
**Форматирование строк**  
Освоить различные методы форматирования строк в Python.  
Научиться применять эти методы в контексте описания соревнования. История: соперничество двух команд - Мастера кода и Волшебники данных.

**Файлы в операционной системе**  
Освоить работу с файловой системой в Python, используя модуль **os**.  
Научиться применять методы **os.walk, os.path.join, os.path.getmtime, os.path.dirname, os.path.getsize** и использование модуля **time** для корректного отображения времени.

Задание:
1. Используйте **os.wal**k для обхода каталога, путь к которому указывает переменная **directory**
2. Примените **os.path.join** для формирования полного пути к файлам.
3. Используйте **os.path.getmtime** и модуль **time** для получения и отображения времени последнего изменения файла.
4. Используйте **os.path.getsize** для получения размера файла.
5. Используйте **os.path.dirname** для получения родительской директории файла.

Комментарии к заданию:  
* Ключевая идея – использование вложенного **for**
___

# Исключения
## Задача 16 (Task 8.1) Urban

Задание **"Программистам всё можно"**:  
Пора разрушать шаблоны привычного нам Python! Вот вас раздражает, что мы не можем сложить число(int) и строку(str)? Давайте исправим это недоразумение!

Реализуйте следующую функцию:
* **add_everything_up**, будет складывать числа**(int, float)** и строки**(str**)

Описание функции:
* **add_everything_up(a, b)** принимает **a** и **b**, которые могут быть как числами(int, float), так и строками(str).
* **TypeError** - когда **a** и **b** окажутся разными типами (числом и строкой), то возвращать строковое представление этих двух данных вместе (в том же порядке). Во всех остальных случаях выполнять стандартные действия.

Пример кода:
* print(add_everything_up(123.456, 'строка'))
* print(add_everything_up('яблоко', 4215))
* print(add_everything_up(123.456, 7))

## Задача 17 (Task 8.2) Urban
**Задача "План перехват":**

Напишите 2 функции:
1. Функция **personal_sum(numbers)**:
> * Должна принимать коллекцию numbers.
> * Подсчитывать сумму чисел в **numbers** путём перебора и увеличивать переменную **result**.
> * Если же при переборе встречается данное типа отличного от числового, то 
обработать исключение **TypeError**, увеличив счётчик **incorrect_data** на **1**.   
>   
> В конечном итоге функция возвращает кортеж из двух значений: 
> * **result** - сумма чисел, 
> * **incorrect_data** - кол-во некорректных данных.

2. Функция **calculate_average(numbers)**:
> Среднее арифметическое - сумма всех данных делённая на их количество.
> * Должна принимать коллекцию **numbers** и возвращать: среднее арифметическое всех чисел.
> * Внутри для подсчёта суммы используйте функцию **personal_sum** написанную ранее.
> 
> Т.к. коллекция **numbers** может оказаться пустой, то обработайте исключение: 
> * **ZeroDivisionError** при делении на **0** и верните **0**.  
> Также в **numbers** может быть записана не коллекция, а другие типы данных, 
например числа. Обработайте исключение:
> *  **TypeError** выводя 
строку **'В numbers записан некорректный тип данных'**. В таком случае 
функция просто вернёт **None**.

## Задача 18 (Task 8.3) Urban
**Задача "Некорректность":**  
Создайте 3 класса (2 из которых будут исключениями):  
Класс **Car** должен обладать следующими свойствами:
1. Атрибут объекта **model** - название автомобиля (строка).
2. Атрибут объекта **__vin** - **vin** номер автомобиля (целое число). Уровень 
доступа **private**.
3. Метод **__is_valid_vin(vin_number)** - принимает **vin_number** и проверяет его на 
корректность. Возвращает **True**, если корректный, в других случаях выбрасывает 
исключение. Уровень доступа **private**.
4. Атрибут **__numbers** - номера автомобиля (строка).
5. Метод **__is_valid_numbers(numbers)** - принимает **numbers** и проверяет его на 
корректность. Возвращает **True**, если корректный, в других случаях выбрасывает 
исключение. Уровень доступа **private**.
6. Классы исключений **IncorrectVinNumber** и **IncorrectCarNumbers**, объекты которых 
обладают атрибутом:
   *  **message** - сообщение, которое будет выводиться при выбрасывании 
   исключения.

Работа методов **__is_valid_vin** и **__is_valid_numbers**:  
**__is_valid_vin**
1. Выбрасывает исключение **IncorrectVinNumber** с сообщением '_Некорректный 
тип vin номер_', если передано не целое число. (тип данных можно проверить 
функцией **isinstance**).
2. Выбрасывает исключение **IncorrectVinNumber** с сообщением '_Неверный 
диапазон для vin номера_', если переданное число находится не в диапазоне 
от **1000000** до **9999999** включительно.
3. Возвращает **True**, если исключения не были выброшены.

**__is_valid_numbers**  
1. Выбрасывает исключение **IncorrectCarNumbers** с сообщением '_Некорректный тип 
данных для номеров_', если передана не строка. (тип данных можно проверить 
функцией **isinstance**).
2. Выбрасывает исключение **IncorrectCarNumbers** с сообщением '_Неверная длина 
номера_', переданная строка должна состоять ровно из 6 символов.
3. Возвращает **True**, если исключения не были выброшены.

**ВАЖНО!**  
Методы **__is_valid_vin** и **__is_valid_numbers** должны вызываться при создании 
объекта (в **\_\_init__** при объявлении атрибутов **__vin** и **__numbers**).

## Задача 19 (Task 9.1) Urban
**Задача "Вызов разом"**:

Напишите функцию **apply_all_func(int_list, *functions)**, которая принимает параметры:
* **int_list** - список из чисел (int, float)
* **\*functions** - неограниченное кол-во функций (которые применимы к спискам, 
состоящим из чисел)

Эта функция должна:
1. Вызвать каждую функцию к переданному списку **int_list**
2. Возвращать словарь, где ключом будет название вызванной функции, а 
значением - её результат работы со списком **int_list**.

Пункты задачи:
1. В функции apply_all_func создайте пустой словарь results.
2. Переберите все функции из *functions.
3. При переборе функций записывайте в словарь results результат работы этой функции под ключом её названия.
4. Верните словарь results.
5. Запустите функцию apply_all_func, передав в неё список из чисел и 
набор других функций.

В примере используются следующие функции:
* min - принимает список, возвращает минимальное значение из него.
* max - принимает список, возвращает максимальное значение из него.
* len - принимает список, возвращает кол-во элементов в нём.
* sum - принимает список, возвращает сумму его элементов.
* sorted - принимает список, возвращает новый отсортированный список на основе 
переданного.

## Задача 20 (Task 9.2) Urban
Задача:  
Даны несколько списков, состоящих из строк:
* first_strings = ['Elon', 'Musk', 'Programmer', 'Monitors', 'Variable']
* second_strings = ['Task', 'Git', 'Comprehension', 'Java', 'Computer', 'Assembler']

В переменную **first_result** запишите список созданный при помощи сборки 
состоящий из длин строк списка **first_strings**, при условии, что длина строк 
не менее **5** символов.  
В переменную **second_result** запишите список созданный при помощи сборки 
состоящий из пар слов(кортежей) одинаковой длины. Каждое слово из списка 
**first_strings** должно сравниваться с каждым из **second_strings**. (два цикла).  
В переменную **third_result** запишите словарь созданный при помощи сборки, 
где парой ключ-значение будет строка-длина строки. Значения строк будут 
перебираться из объединённых вместе списков **first_strings** и **second_strings**. 
Условие записи пары в словарь - **чётная длина строки**.

## Задача 21 (Task 9.3) Urban
Задача:  
Дано 2 списка:  
**first = ['Strings', 'Student', 'Computers']**  
**second = ['Строка', 'Урбан', 'Компьютер']**  

Необходимо создать 2 генераторных сборки:
1. В переменную **first_result** запишите генераторную сборку, которая высчитывает 
разницу длин строк из списков **first** и **second**, если их длины не равны. Для 
перебора строк попарно из двух списков используйте функцию **zip**.
2. В переменную **second_result** запишите генераторную сборку, которая содержит 
результаты сравнения длин строк в одинаковых позициях из списков **first** и **second**. 
Составьте эту сборку **НЕ** используя функцию **zip**. Используйте 
функции **range** и **len**.

## Задача 22 (Task 9.4) Urban
**Задача "Функциональное разнообразие"**  
**Lambda-функция:**  
Даны 2 строки:  
**first = 'Мама мыла раму'**
**second = 'Рамена мало было'**  
Необходимо составить lambda-функцию для следующего 
выражения - **list(map(?, first, second))**.  
Здесь **?** - место написания lambda-функции.  
Результатом должен быть список совпадения букв в той же позиции:
> [False, True, True, False, False, False, False, False, True, False, 
False, False, False, False]  

Где **True** - совпало, **False** - не совпало.

**Замыкание:**
Напишите функцию **get_advanced_writer(file_name)**, принимающую название 
файла для записи.  
Внутри этой функции, напишите ещё одну - **write_everything(*data_set)**, где 
**\*data_set** - параметр принимающий неограниченное количество данных любого типа.  
Логика **write_everything** заключается в добавлении в файл **file_name** всех 
данных из **data_set** в том же виде.  
Функция **get_advanced_writer** возвращает функцию **write_everything**.  
Данный код:
> write = get_advanced_writer('example.txt')  
> write('Это строчка', ['А', 'это', 'уже', 'число', 5, 'в', 'списке'])

Запишет данные в файл в таком виде:

**Метод __call__:**  
Создайте класс **MysticBall**, объекты которого обладают атрибутом **words** 
хранящий коллекцию строк.  
В этом классе также определите метод **\_\_call__** который будет случайным 
образом выбирать слово из **words** и возвращать его. Для случайного выбора 
с одинаковой вероятностью для каждого данного в коллекции можете 
использовать функцию **choice** из модуля **random**.

## Задача 23 (Task 9.5) Urban
**Задача "Range - это просто":**  
Создайте пользовательский класс исключения **StepValueError**, который 
наследуется от **ValueError**.
Наследования достаточно, класс оставьте пустым при помощи оператора **pass**.

Создайте класс **Iterator**, который обладает следующими свойствами.
Атрибуты объекта:
* **start** - целое число, с которого начинается итерация.
* **stop** - целое число, на котором заканчивается итерация.
* **step** - шаг, с которым совершается итерация.
* **pointer** - указывает на текущее число в итерации (изначально **start**)

Методы:
* **\_\_init__(self, start, stop, step=1)** - принимающий значения старта и 
конца итерации, а также шага. В этом методе в первую очередь проверяется 
step на равенство **0**. Если равно, то выбрасывается исключение 
StepValueError('шаг не может быть равен 0')
* **\_\_iter__** - метод, сбрасывающий значение pointer на **start** и возвращающий 
сам объект итератора.
* **\_\_next__** - метод, увеличивающий атрибут **pointer** на **step**. В зависимости 
от знака атрибута step итерация завершится либо когда **pointer** станет 
больше **stop**, либо меньше **stop**. Учтите это при описании метода.

Пункты задачи:
1. Создайте класс исключения **StepValueError**.
2. Создайте класс **Iterator** и опишите его атрибуты и методы.
3. Создайте несколько объектов класса **Iterator** и совершите итерации 
с ними при помощи цикла **for**.

## Задача 24 (Task 9.6) Urban
**Задача: "Вперед по шагу"**  
Напишите функцию-генератор **all_variants(text)**, которая принимает строку **text** 
и возвращает объект-генератор, при каждой итерации которого будет 
возвращаться подпоследовательности переданной строки.  
Пункты задачи:
1. Напишите функцию-генератор all_variants(text).
2. Опишите логику работы внутри функции all_variants.
3. Вызовите функцию all_variants и выполните итерации.

Пример работы функции:
> a = all_variants("abc")  
for i in a:  
print(i)

Вывод на консоль:
> a  
b  
c  
ab  
bc  
abc

## Задача 25 (Task 9.7) Urban
**Задание: Декораторы в Python**  
Цель задания: Освоить механизмы создания декораторов Python.  
Практически применить знания, создав функцию декоратор и обернув ею другую функцию.

Задание:
1. Напишите 2 функции:
2. Функция, которая складывает 3 числа (**sum_three**)
3. Функция декоратор (**is_prime**), которая распечатывает **"Простое"**, если 
результат 1ой функции будет простым числом и **"Составное"** в противном случае.