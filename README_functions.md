# Urban-Homework
My homeworks on Urban University learning
## Задача 1 (Task 1)
Напишите функцию высшего порядка, которая получает в качестве аргумента две функции первого порядка:
* Функцию для преобразования текста сообщения в верхний регистр.
* Функцию для преобразования текста сообщения в нижний регистр.
___

## Задача 2 (Task 2)
Часто при разработке и работе с рассылками писем (e-mail) они отправляются от одного и того же пользователя(администрации или службы поддержки). Тем не менее должна быть возможность сменить его в редких случаях. \
Создайте функцию **send_email**, которая принимает 2 обычных аргумента: сообщение и получатель и 1 обязательно именованный аргумент со значением по умолчанию - отправитель.\
Внутри функции реализовать следующую логику:
* Проверка на корректность e-mail отправителя и получателя.
* Проверка на отправку самому себе.
* Проверка на отправителя по умолчанию.
#### Пункты задачи:
1. Создайте функцию **send_email**, которая принимает 2 обычных аргумента: **message** (сообщение), **recipient** (получатель) и 1 обязательно именованный аргумент со значением по умолчанию **sender = "university.help@gmail.com"**.
2. Если строки **recipient** и **sender** не содержит **"@"** или не оканчивается на **".com"**, **".ru"**, **".net"**, то вывести на экран(в консоль) строку: "_Невозможно отправить письмо с адреса_ <**sender**> на адрес <**recipient**>".
3. Если же **sender** и **recipient** совпадают, то вывести "_Нельзя отправить письмо самому себе!_"
4. Если же отправитель по умолчанию - **university.help@gmail.com**, то вывести сообщение: "_Письмо успешно отправлено с адреса_ <**sender**> _на адрес_ <**recipient**>."
5. В противном случае вывести сообщение: "_НЕСТАНДАРТНЫЙ ОТПРАВИТЕЛЬ! Письмо отправлено с адреса_ <**sender**> _на адрес_ <**recipient**>."
6. За один вызов функции выводится **только одно** и перечисленных уведомлений! Проверки перечислены по мере выполнения.
___

## Задача 3 (Task 3) 
### Фукнции. Запаковка и распаковка параметров
Задача "Распаковка":\
**Функция с параметрами по умолчанию:**
1. Создайте функцию **print_params**(a = 1, b = 'строка', c = True), которая принимает три параметра со значениями по умолчанию (например сейчас это: **1, 'строка', True**).
2. Функция должна выводить эти параметры.
3. Вызовите функцию **print_params** с разным количеством аргументов, включая вызов без аргументов.
4. Проверьте, работают ли вызовы **print_params**(b = 25) **print_params**(c = [1,2,3])

**Распаковка параметров:**

1. Создайте список **values_list** с тремя элементами разных типов.
2. Создайте словарь **values_dict** с тремя ключами, соответствующими параметрам функции **print_params**, и значениями разных типов.
3. Передайте **values_list** и **values_dict** в функцию **print_params**, используя распаковку параметров (* для списка и ** для словаря).

**Распаковка + отдельные параметры:**

1. Создайте список **values_list_2** с двумя элементами разных типов
2. Проверьте, работает ли **print_params**(*values_list_2, 42)

**Пример результата выполнения программы:**  
Исходный код:
> values_list_2 = [54.32, 'Строка' ]\
>print_params(*values_list_2, 42) 
> 
Вывод на консоль:
>54.32 'Строка' 42
___

## Задача 4 (Task 4)
**Задача "Однокоренные":**\
Напишите функцию **single_root_words**, которая принимает одно обязательное слово в 
параметр **root_word**, а далее неограниченную последовательность в 
параметр *other_words.

Функция должна составить новый список **same_words** только из тех слов списка **other_words**, которые содержат **root_word** или наоборот **root_word** содержит одно из этих слов. После вернуть список **same_words** в качестве результата своей работы.

**Пункты задачи:**\
1. Объявите функцию **single_root_words** и напишите в ней параметры **root_word** и ***other_words**.
2. Создайте внутри функции пустой список **same_words**, который пополнится нужными словами.
3. При помощи цикла **for** переберите предполагаемо подходящие слова.
4. Пропишите корректное относительно задачи условие, при котором добавляются слова в результирующий список **same_words**.
5. После цикла верните образованный функцией список same_words.
6. Вызовите функцию **single_root_words** и выведете на экран(консоль) возвращённое ей значение.
7. Пример результата выполнения программы:

  **Исходный код:**  
> result1 = single_root_words('rich', 'richiest', 'orichalcum', 'cheers', 'richies')  
result2 = single_root_words('Disablement', 'Able', 'Mable', 'Disable', 'Bagel')  
print(result1)  
print(result2)

  **Вывод на консоль:**
> ['richiest', 'orichalcum', 'richies']  
['Able', 'Disable']

**Примечания:**
При проверке наличия одного слова в составе другого стоит учесть, что регистр символов не должен влиять ни на что. (**'Disablement' - 'Able'**) (**'Able', 'able', 'AbLe'** - все подходят)
___

<img src="https://mdg.imgix.net/assets/images/san-juan-mountains.jpg" width="400" height="300">

___
## Задача 5 (Task 5) "Раз, два, три, четыре, пять .... Это не всё?":
Наши студенты, без исключения, - очень умные ребята. Настолько умные, 
что иногда по утру сами путаются в том, что намудрили вчера вечером.  
Один из таких учеников уснул на клавиатуре в процессе упорной учёбы 
(ещё и трудолюбивые). Тем не менее, даже после сна, его код остался рабочим и 
выглядел следующим образом:  
> **data_structure = [  
  [1, 2, 3],  
  {'a': 4, 'b': 5},  
  (6, {'cube': 7, 'drum': 8}),  
  "Hello",  
  ((), [{(2, 'Urban', ('Urban2', 35))}])  
]**

Увидев это студент задался вопросом: "А есть ли универсальное решение для 
подсчёта суммы всех чисел и длин всех строк?"  
Да, выглядит страшно, да и обращаться нужно к каждой внутренней структуре 
(списку, словарю и т.д.) по-разному.  
Ученику пришлось каждый раз использовать индексацию и обращение по 
ключам - универсального решения для таких структур он не нашёл.  

**Помогите сокурснику осуществить его задумку.**  
Что должно быть подсчитано:  
* Все числа (не важно, являются они ключами или значениям или ещё чем-то).
* Размеры всех строк (не важно, являются они ключами или значениям или ещё чем-то)  

Для примера, указанного выше, расчёт вёлся следующим образом:  
1 + 2 + 3 + len('a') + 4 + len('b') + 5 + 6 + len('cube') + 7 + .... + 35 = 99