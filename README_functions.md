# Urban-Homework
My homeworks on Urban University learning
## Задача 1 (Task 1)
Напишите функцию высшего порядка, которая получает в качестве аргумента две функции первого порядка:
* Функцию для преобразования текста сообщения в верхний регистр.
* Функцию для преобразования текста сообщения в нижний регистр.
___

## Задача 2 (Task 2)
Часто при разработке и работе с рассылками писем (e-mail) они отправляются от одного и того же пользователя(администрации или службы поддержки). Тем не менее должна быть возможность сменить его в редких случаях. \
Создайте функцию **send_email**, которая принимает 2 обычных аргумента: сообщение и получатель и 1 обязательно именованный аргумент со значением по умолчанию - отправитель.\
Внутри функции реализовать следующую логику:
* Проверка на корректность e-mail отправителя и получателя.
* Проверка на отправку самому себе.
* Проверка на отправителя по умолчанию.
#### Пункты задачи:
1. Создайте функцию **send_email**, которая принимает 2 обычных аргумента: **message** (сообщение), **recipient** (получатель) и 1 обязательно именованный аргумент со значением по умолчанию **sender = "university.help@gmail.com"**.
2. Если строки **recipient** и **sender** не содержит **"@"** или не оканчивается на **".com"**, **".ru"**, **".net"**, то вывести на экран(в консоль) строку: "_Невозможно отправить письмо с адреса_ <**sender**> на адрес <**recipient**>".
3. Если же **sender** и **recipient** совпадают, то вывести "_Нельзя отправить письмо самому себе!_"
4. Если же отправитель по умолчанию - **university.help@gmail.com**, то вывести сообщение: "_Письмо успешно отправлено с адреса_ <**sender**> _на адрес_ <**recipient**>."
5. В противном случае вывести сообщение: "_НЕСТАНДАРТНЫЙ ОТПРАВИТЕЛЬ! Письмо отправлено с адреса_ <**sender**> _на адрес_ <**recipient**>."
6. За один вызов функции выводится **только одно** и перечисленных уведомлений! Проверки перечислены по мере выполнения.
___

## Задача 3 (Task 3) 
### Фукнции. Запаковка и распаковка параметров
Задача "Распаковка":\
**Функция с параметрами по умолчанию:**
1. Создайте функцию **print_params**(a = 1, b = 'строка', c = True), которая принимает три параметра со значениями по умолчанию (например сейчас это: **1, 'строка', True**).
2. Функция должна выводить эти параметры.
3. Вызовите функцию **print_params** с разным количеством аргументов, включая вызов без аргументов.
4. Проверьте, работают ли вызовы **print_params**(b = 25) **print_params**(c = [1,2,3])

**Распаковка параметров:**

1. Создайте список **values_list** с тремя элементами разных типов.
2. Создайте словарь **values_dict** с тремя ключами, соответствующими параметрам функции **print_params**, и значениями разных типов.
3. Передайте **values_list** и **values_dict** в функцию **print_params**, используя распаковку параметров (* для списка и ** для словаря).

**Распаковка + отдельные параметры:**

1. Создайте список **values_list_2** с двумя элементами разных типов
2. Проверьте, работает ли **print_params**(*values_list_2, 42)

**Пример результата выполнения программы:**  
Исходный код:
> values_list_2 = [54.32, 'Строка' ]\
>print_params(*values_list_2, 42) 
> 
Вывод на консоль:
>54.32 'Строка' 42
___

## Задача 4 (Task 4)
**Задача "Однокоренные":**\
Напишите функцию **single_root_words**, которая принимает одно обязательное слово в 
параметр **root_word**, а далее неограниченную последовательность в 
параметр *other_words.

Функция должна составить новый список **same_words** только из тех слов списка **other_words**, которые содержат **root_word** или наоборот **root_word** содержит одно из этих слов. После вернуть список **same_words** в качестве результата своей работы.

**Пункты задачи:**\
1. Объявите функцию **single_root_words** и напишите в ней параметры **root_word** и ***other_words**.
2. Создайте внутри функции пустой список **same_words**, который пополнится нужными словами.
3. При помощи цикла **for** переберите предполагаемо подходящие слова.
4. Пропишите корректное относительно задачи условие, при котором добавляются слова в результирующий список **same_words**.
5. После цикла верните образованный функцией список same_words.
6. Вызовите функцию **single_root_words** и выведете на экран(консоль) возвращённое ей значение.
7. Пример результата выполнения программы:

  **Исходный код:**  
> result1 = single_root_words('rich', 'richiest', 'orichalcum', 'cheers', 'richies')  
result2 = single_root_words('Disablement', 'Able', 'Mable', 'Disable', 'Bagel')  
print(result1)  
print(result2)

  **Вывод на консоль:**
> ['richiest', 'orichalcum', 'richies']  
['Able', 'Disable']

**Примечания:**
При проверке наличия одного слова в составе другого стоит учесть, что регистр символов не должен влиять ни на что. (**'Disablement' - 'Able'**) (**'Able', 'able', 'AbLe'** - все подходят)
___

<img src="https://mdg.imgix.net/assets/images/san-juan-mountains.jpg" width="400" height="300">

___
## Задача 5 (Task 5) 
### "Раз, два, три, четыре, пять .... Это не всё?":
Наши студенты, без исключения, - очень умные ребята. Настолько умные, 
что иногда по утру сами путаются в том, что намудрили вчера вечером.  
Один из таких учеников уснул на клавиатуре в процессе упорной учёбы 
(ещё и трудолюбивые). Тем не менее, даже после сна, его код остался рабочим и 
выглядел следующим образом:  
> **data_structure = [  
  [1, 2, 3],  
  {'a': 4, 'b': 5},  
  (6, {'cube': 7, 'drum': 8}),  
  "Hello",  
  ((), [{(2, 'Urban', ('Urban2', 35))}])  
]**

Увидев это студент задался вопросом: "А есть ли универсальное решение для 
подсчёта суммы всех чисел и длин всех строк?"  
Да, выглядит страшно, да и обращаться нужно к каждой внутренней структуре 
(списку, словарю и т.д.) по-разному.  
Ученику пришлось каждый раз использовать индексацию и обращение по 
ключам - универсального решения для таких структур он не нашёл.  

**Помогите сокурснику осуществить его задумку.**  
Что должно быть подсчитано:  
* Все числа (не важно, являются они ключами или значениям или ещё чем-то).
* Размеры всех строк (не важно, являются они ключами или значениям или ещё чем-то)  

Для примера, указанного выше, расчёт вёлся следующим образом:  
1 + 2 + 3 + len('a') + 4 + len('b') + 5 + 6 + len('cube') + 7 + .... + 35 = 99
___

## Задача 6 (Task 6) Urban
### "А как делить?":

В школе нам говорили, что на 0 делить нельзя. Высшая же математика опровергает это и 
говорит, что результат при делении на 0 будет стремиться к бесконечности.  
Давайте реализуем оба способа, чтобы у вас всегда был выбор!  
Создайте модули **fake_math** и **true_math** в которых создайте функции отвечающие 
за деление, но разными способами.  
В **fake_math** создайте функцию **divide**, которая принимает два параметра **first** 
и **second**. Функция должна возвращать результат деления **first** на **second**, но 
когда в second записан 0 - возвращать строку **'Ошибка'**.  
В **true_math** создайте функцию **divide**, которая принимает два параметра **first** 
и **second**. 
Функция должна возвращать результат деления **first** на **second**, но когда в 
second записан 0 - возвращать **бесконечность**.  
Бесконечность можно импортировать из встроенной библиотеки **math** (_from math import
inf_)  
**Пункты задачи:**
* Создайте модули **fake_math** и **true_math**.
* Напишите функции **divide** в обоих методах. Разница между этими функциями - 
возвращаемое значение.
* Создайте модуль **module_4_1** (если ещё не создан), импортируйте в него 
функции **divide** из модулей **fake_math** и **true_math**, назвав их разными 
именами на своё усмотрение, чтобы не было конфликтов имён, при помощи оператора **as**.
* Запустите эти функции в модуле **module_4_1**, передав первым аргументом 
произвольное число отличное от 0, вторым аргументом - 0
* Выведи результаты вызовов этих функций на экран(в консоль).
___

## Задача 7 (Task 7) Urban
### "Developer - не только разработчик":  
Файл **module_5_1.py**   
Реализуйте класс **House**, объекты которого будут создаваться следующим образом:
* House('ЖК Эльбрус', 30)      

Объект этого класса должен обладать следующими атрибутами:
* **self.name** - имя, **self.number_of_floors** - кол-во этажей

Также должен обладать методом **go_to(new_floor)**, где **new_floor** - номер этажа(int), на который нужно приехать.  
Метод **go_to** выводит на экран(в консоль) значения от 1 до **new_floor**(включительно).  
Если же **new_floor** больше чем **self.number_of_floors** или меньше **1**, то вывести строку **"Такого этажа не существует"**.

Пункты задачи:
* Создайте класс House.
* Внутри класса House определите метод  **\_\_init__**, в который передадите название и кол-во этажей.
* Внутри метода **\_\_init__** создайте атрибуты объекта **self.name** и **self.number_of_floors**, присвойте им переданные значения.
* Создайте метод **go_to** с параметром **new_floor** и напишите логику внутри него на основе описания задачи.
* Создайте объект класса **House** с произвольным названием и количеством этажей.
* Вызовите метод **go_to** у этого объекта с произвольным числом.

## Задача 8 (Task 8) Urban HARD
**Задание "Свой YouTube":**  
Университет Urban подумывает о создании своей платформы, где будут размещаться дополнительные полезные ролики на тему IT (юмористические, интервью и т.д.). Конечно же для старта написания интернет ресурса требуются хотя бы базовые знания программирования.  
Именно вам выпала возможность продемонстрировать их, написав небольшой набор классов, которые будут выполнять похожий функционал на сайте.   
Всего будет 3 класса: **UrTube, Video, User.**

**Общее ТЗ:**   
Реализовать классы для взаимодействия с платформой, каждый из которых будет содержать методы добавления видео, авторизации и регистрации пользователя и т.д.

**Подробное ТЗ:**  
Каждый объект класса **User** должен обладать следующими атрибутами и методами:
* Атрибуты: **nickname**(имя пользователя, строка), **password**(в хэшированном виде, число), **age**(возраст, число)

Каждый объект класса **Video** должен обладать следующими атрибутами и методами:
* Атрибуты: **title**(заголовок, строка), **duration**(продолжительность, секунды), **time_now**(секунда остановки (изначально 0)), **adult_mode**(ограничение по возрасту, **bool** (**False** по умолчанию))

Каждый объект класса **UrTube** должен обладать следующими атрибутами и методами:
1. Атрибуты: **users**(список объектов User), **videos**(список объектов Video), **current_user**(текущий пользователь, User)
2. Метод **log_in**, который принимает на вход аргументы: **nickname**, **password** и пытается найти пользователя в **users** с такими же логином и паролем. Если такой пользователь существует, то **current_user** меняется на найденного. Помните, что **password** передаётся в виде строки, а сравнивается по хэшу.
3. Метод **register**, который принимает три аргумента: **nickname, password, age,** и добавляет пользователя в список, если пользователя не существует (с таким же **nickname**). Если существует, выводит на экран: "Пользователь {nickname} уже существует". После регистрации, вход выполняется автоматически.
4. Метод **log_out** для сброса текущего пользователя на **None**.
5. Метод **add**, который принимает неограниченное кол-во объектов класса **Video** и все добавляет в **videos**, если с таким же названием видео ещё не существует. В противном случае ничего не происходит.
6. Метод **get_videos**, который принимает поисковое слово и возвращает список названий всех видео, содержащих поисковое слово. Следует учесть, что слово 'UrbaN' присутствует в строке **'Urban the best'** (не учитывать регистр).
7. Метод **watch_video**, который принимает название фильма, если не находит точного совпадения(вплоть до пробела), то ничего не воспроизводится, если же находит - ведётся отчёт в консоль на какой секунде ведётся просмотр. После текущее время просмотра данного видео сбрасывается.

Для метода **watch_video** так же учитывайте следующие особенности:
1. Для паузы между выводами секунд воспроизведения можно использовать функцию **sleep** из модуля **time**.
2. Воспроизводить видео можно только тогда, когда пользователь вошёл в **UrTube**. В противном случае выводить в консоль надпись: "Войдите в аккаунт, чтобы смотреть видео"
3. Если видео найдено, следует учесть, что пользователю может быть отказано в просмотре, т.к. есть ограничения 18+. Должно выводиться сообщение: "Вам нет 18 лет, пожалуйста покиньте страницу"
4. После воспроизведения нужно выводить: "Конец видео"

Примечания:
* Не забывайте для удобства использовать **dunder**(магические) методы: **\_\_str__, \_\_repr__, \_\_contains__, \_\_eq__** и др. (повторить можно здесь)
* Чтобы не запутаться, рекомендуется после реализации каждого метода проверять как он работает, тестировать разные вариации.

# Наследование классов
## Задача 9 (Task 6.1) Urban 
**Задача "Съедобное, несъедобное":**
Разнообразие животного мира давно будоражит умы человечества. Царства, классы, виды... Почему бы и нам не попробовать выстроить что-то подобное используя наследования классов?  
Необходимо описать пример иерархии животного мира, используя классы и принцип наследования.  
**Создайте:**
* 2 класса родителя: **Animal, Plant**

Для класса **Animal** атрибуты **alive = True(живой)** и **fed = False(накормленный)**, **name** - индивидуальное название каждого животного.   
Для класса **Plant** атрибут **edible = False(съедобность)**, **name** - индивидуальное название каждого растения

* 4 класса наследника:

* **Mammal, Predator** для **Animal**.
* **Flower, Fruit** для **Plant**.

У каждого из объектов класса **Mammal** и **Predator** должны быть атрибуты и методы:
* **eat(self, food)** - метод, где **food** - это параметр, принимающий объекты классов растений.

Метод **eat** должен работать следующим образом:
* Если переданное растение (**food**) съедобное - выводит на экран **"<self.name> съел <food.name>"**, меняется атрибут **fed** на **True**.
* Если переданное растение (**food**) не съедобное - выводит на экран **"<self.name> не стал есть <food.name>"**, меняется атрибут **alive** на **False**.

Т.е если животному дать съедобное растение, то животное насытится, если не съедобное - погибнет.  
У каждого объекта **Fruit** должен быть атрибут **edible = True** (переопределить при наследовании).  
Создайте объекты классов и проделайте действия затронутые в примере результата работы программы.  
Пункты задачи:
1. Создайте классы Animal и Plant с соответствующими атрибутами и методами
2. Создайте(+унаследуйте) классы Mammal, Predator, Flower, Fruit с соответствующими атрибутами и методами. При необходимости переопределите значения атрибутов.
3. Создайте объекты этих классов.

## Задача 10 (Task 6.2) Urban 
**Задача "Изменять нельзя получать":**

В этой задаче мы реализуем классы транспорта, в которых нельзя будет просто так 
поменять цвет, мощность двигателя и прочие свойства, т.к. в реальной жизни это 
чаще всего делается не владельцем, а в специальных сервисах. Да, узнать значения 
этих свойств мы сможем, но вот изменить - нет.  
Вам необходимо создать 2 класса: **Vehicle** и **Sedan**, где **Vehicle** - это 
любой транспорт, а **Sedan(седан)** - наследник класса **Vehicle**.   
**I.** Каждый объект **Vehicle** должен содержать следующие атрибуты объекта:
1. Атрибут **owner(str)** - владелец транспорта. (владелец может меняться)
2. Атрибут **__model(str)** - модель (марка) транспорта. (мы не можем менять название модели)
3. Атрибут **__engine_power(int**) - мощность двигателя. (мы не можем менять мощность двигателя самостоятельно)
4. Атрибут **__color(str)** - название цвета. (мы не можем менять цвет автомобиля своими руками)

А так же атрибут класса:  
1. Атрибут класса **__COLOR_VARIANTS**, в который записан список допустимых цветов для окрашивания. (Цвета написать свои)

Каждый объект **Vehicle** должен содержать следующий методы:
1. Метод **get_model** - возвращает строку: *\"Модель: <название модели транспорта>"*
2. Метод **get_horsepower** - возвращает строку: *\"Мощность двигателя: <мощность>"*
3. Метод **get_color** - возвращает строку: *\"Цвет: <цвет транспорта>"*
4. Метод **print_info** - распечатывает результаты методов (в том же порядке): **get_model, get_horsepower, get_color**; а так же владельца в конце в формате *\"Владелец: <имя>"*
5. Метод **set_color** - принимает аргумент **new_color(str)**, меняет цвет **__color** на **new_color**, если он есть в списке **__COLOR_VARIANTS**, в противном случае выводит на экран надпись: *\"Нельзя сменить цвет на <новый цвет>".*

Взаимосвязь методов и скрытых атрибутов:
* Методы **get_model, get_horsepower, get_color** находятся в одном классе с соответствующими им атрибутами: **__model, __engine_power, __color**. Поэтому атрибуты будут доступны для методов.
* Атрибут класса **__COLOR_VARIANTS** можно получить обращаясь к нему через объект**(self)**.
* Проверка в **__COLOR_VARIANTS** происходит не учитывая регистр ('BLACK' ~ 'black').

**II.** Класс **Sedan** наследуется от класса **Vehicle**, а так же содержит следующие атрибуты:
* Атрибут **__PASSENGERS_LIMIT = 5** (в седан может поместиться только 5 пассажиров)

Пункты задачи:
* Создайте классы **Vehicle** и **Sedan**.
* Напишите соответствующие свойства в обоих классах.
* Не забудьте сделать **Sedan** наследником класса **Vehicle**.
* Создайте объект класса **Sedan** и проверьте, как работают все его методы, взяты из класса **Vehicle**.