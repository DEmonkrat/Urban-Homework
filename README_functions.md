# Urban-Homework
My homeworks on Urban University learning
## Задача 1 (Task 1)
Напишите функцию высшего порядка, которая получает в качестве аргумента две функции первого порядка:
* Функцию для преобразования текста сообщения в верхний регистр.
* Функцию для преобразования текста сообщения в нижний регистр.
___

## Задача 2 (Task 2)
Часто при разработке и работе с рассылками писем (e-mail) они отправляются от одного и того же пользователя(администрации или службы поддержки). Тем не менее должна быть возможность сменить его в редких случаях. \
Создайте функцию **send_email**, которая принимает 2 обычных аргумента: сообщение и получатель и 1 обязательно именованный аргумент со значением по умолчанию - отправитель.\
Внутри функции реализовать следующую логику:
* Проверка на корректность e-mail отправителя и получателя.
* Проверка на отправку самому себе.
* Проверка на отправителя по умолчанию.
#### Пункты задачи:
1. Создайте функцию **send_email**, которая принимает 2 обычных аргумента: **message** (сообщение), **recipient** (получатель) и 1 обязательно именованный аргумент со значением по умолчанию **sender = "university.help@gmail.com"**.
2. Если строки **recipient** и **sender** не содержит **"@"** или не оканчивается на **".com"**, **".ru"**, **".net"**, то вывести на экран(в консоль) строку: "_Невозможно отправить письмо с адреса_ <**sender**> на адрес <**recipient**>".
3. Если же **sender** и **recipient** совпадают, то вывести "_Нельзя отправить письмо самому себе!_"
4. Если же отправитель по умолчанию - **university.help@gmail.com**, то вывести сообщение: "_Письмо успешно отправлено с адреса_ <**sender**> _на адрес_ <**recipient**>."
5. В противном случае вывести сообщение: "_НЕСТАНДАРТНЫЙ ОТПРАВИТЕЛЬ! Письмо отправлено с адреса_ <**sender**> _на адрес_ <**recipient**>."
6. За один вызов функции выводится **только одно** и перечисленных уведомлений! Проверки перечислены по мере выполнения.
___

## Задача 3 (Task 3) 
### Фукнции. Запаковка и распаковка параметров
Задача "Распаковка":\
**Функция с параметрами по умолчанию:**
1. Создайте функцию **print_params**(a = 1, b = 'строка', c = True), которая принимает три параметра со значениями по умолчанию (например сейчас это: **1, 'строка', True**).
2. Функция должна выводить эти параметры.
3. Вызовите функцию **print_params** с разным количеством аргументов, включая вызов без аргументов.
4. Проверьте, работают ли вызовы **print_params**(b = 25) **print_params**(c = [1,2,3])

**Распаковка параметров:**

1. Создайте список **values_list** с тремя элементами разных типов.
2. Создайте словарь **values_dict** с тремя ключами, соответствующими параметрам функции **print_params**, и значениями разных типов.
3. Передайте **values_list** и **values_dict** в функцию **print_params**, используя распаковку параметров (* для списка и ** для словаря).

**Распаковка + отдельные параметры:**

1. Создайте список **values_list_2** с двумя элементами разных типов
2. Проверьте, работает ли **print_params**(*values_list_2, 42)

**Пример результата выполнения программы:**  
Исходный код:
> values_list_2 = [54.32, 'Строка' ]\
>print_params(*values_list_2, 42) 
> 
Вывод на консоль:
>54.32 'Строка' 42
___

## Задача 4 (Task 4)
**Задача "Однокоренные":**\
Напишите функцию **single_root_words**, которая принимает одно обязательное слово в 
параметр **root_word**, а далее неограниченную последовательность в 
параметр *other_words.

Функция должна составить новый список **same_words** только из тех слов списка **other_words**, которые содержат **root_word** или наоборот **root_word** содержит одно из этих слов. После вернуть список **same_words** в качестве результата своей работы.

**Пункты задачи:**\
1. Объявите функцию **single_root_words** и напишите в ней параметры **root_word** и ***other_words**.
2. Создайте внутри функции пустой список **same_words**, который пополнится нужными словами.
3. При помощи цикла **for** переберите предполагаемо подходящие слова.
4. Пропишите корректное относительно задачи условие, при котором добавляются слова в результирующий список **same_words**.
5. После цикла верните образованный функцией список same_words.
6. Вызовите функцию **single_root_words** и выведете на экран(консоль) возвращённое ей значение.
7. Пример результата выполнения программы:

  **Исходный код:**  
> result1 = single_root_words('rich', 'richiest', 'orichalcum', 'cheers', 'richies')  
result2 = single_root_words('Disablement', 'Able', 'Mable', 'Disable', 'Bagel')  
print(result1)  
print(result2)

  **Вывод на консоль:**
> ['richiest', 'orichalcum', 'richies']  
['Able', 'Disable']

**Примечания:**
При проверке наличия одного слова в составе другого стоит учесть, что регистр символов не должен влиять ни на что. (**'Disablement' - 'Able'**) (**'Able', 'able', 'AbLe'** - все подходят)
___

<img src="https://mdg.imgix.net/assets/images/san-juan-mountains.jpg" width="400" height="300">

___
## Задача 5 (Task 5) 
### "Раз, два, три, четыре, пять .... Это не всё?":
Наши студенты, без исключения, - очень умные ребята. Настолько умные, 
что иногда по утру сами путаются в том, что намудрили вчера вечером.  
Один из таких учеников уснул на клавиатуре в процессе упорной учёбы 
(ещё и трудолюбивые). Тем не менее, даже после сна, его код остался рабочим и 
выглядел следующим образом:  
> **data_structure = [  
  [1, 2, 3],  
  {'a': 4, 'b': 5},  
  (6, {'cube': 7, 'drum': 8}),  
  "Hello",  
  ((), [{(2, 'Urban', ('Urban2', 35))}])  
]**

Увидев это студент задался вопросом: "А есть ли универсальное решение для 
подсчёта суммы всех чисел и длин всех строк?"  
Да, выглядит страшно, да и обращаться нужно к каждой внутренней структуре 
(списку, словарю и т.д.) по-разному.  
Ученику пришлось каждый раз использовать индексацию и обращение по 
ключам - универсального решения для таких структур он не нашёл.  

**Помогите сокурснику осуществить его задумку.**  
Что должно быть подсчитано:  
* Все числа (не важно, являются они ключами или значениям или ещё чем-то).
* Размеры всех строк (не важно, являются они ключами или значениям или ещё чем-то)  

Для примера, указанного выше, расчёт вёлся следующим образом:  
1 + 2 + 3 + len('a') + 4 + len('b') + 5 + 6 + len('cube') + 7 + .... + 35 = 99
___

## Задача 6 (Task 6) Urban
### "А как делить?":

В школе нам говорили, что на 0 делить нельзя. Высшая же математика опровергает это и 
говорит, что результат при делении на 0 будет стремиться к бесконечности.  
Давайте реализуем оба способа, чтобы у вас всегда был выбор!  
Создайте модули **fake_math** и **true_math** в которых создайте функции отвечающие 
за деление, но разными способами.  
В **fake_math** создайте функцию **divide**, которая принимает два параметра **first** 
и **second**. Функция должна возвращать результат деления **first** на **second**, но 
когда в second записан 0 - возвращать строку **'Ошибка'**.  
В **true_math** создайте функцию **divide**, которая принимает два параметра **first** 
и **second**. 
Функция должна возвращать результат деления **first** на **second**, но когда в 
second записан 0 - возвращать **бесконечность**.  
Бесконечность можно импортировать из встроенной библиотеки **math** (_from math import
inf_)  
**Пункты задачи:**
* Создайте модули **fake_math** и **true_math**.
* Напишите функции **divide** в обоих методах. Разница между этими функциями - 
возвращаемое значение.
* Создайте модуль **module_4_1** (если ещё не создан), импортируйте в него 
функции **divide** из модулей **fake_math** и **true_math**, назвав их разными 
именами на своё усмотрение, чтобы не было конфликтов имён, при помощи оператора **as**.
* Запустите эти функции в модуле **module_4_1**, передав первым аргументом 
произвольное число отличное от 0, вторым аргументом - 0
* Выведи результаты вызовов этих функций на экран(в консоль).
___

## Задача 7 (Task 7) Urban
### "Developer - не только разработчик":  
Файл **module_5_1.py**   
Реализуйте класс **House**, объекты которого будут создаваться следующим образом:
* House('ЖК Эльбрус', 30)      

Объект этого класса должен обладать следующими атрибутами:
* **self.name** - имя, **self.number_of_floors** - кол-во этажей

Также должен обладать методом **go_to(new_floor)**, где **new_floor** - номер этажа(int), на который нужно приехать.  
Метод **go_to** выводит на экран(в консоль) значения от 1 до **new_floor**(включительно).  
Если же **new_floor** больше чем **self.number_of_floors** или меньше **1**, то вывести строку **"Такого этажа не существует"**.

Пункты задачи:
* Создайте класс House.
* Вунтри класса House определите метод  **\_\_init__**, в который передадите название и кол-во этажей.
* Внутри метода **\_\_init__** создайте атрибуты объекта **self.name** и **self.number_of_floors**, присвойте им переданные значения.
* Создайте метод **go_to** с параметром **new_floor** и напишите логику внутри него на основе описания задачи.
* Создайте объект класса **House** с произвольным названием и количеством этажей.
* Вызовите метод **go_to** у этого объекта с произвольным числом.

## Задача 8 (Task 8) Urban HARD
**Задание "Свой YouTube":**  
Университет Urban подумывает о создании своей платформы, где будут размещаться дополнительные полезные ролики на тему IT (юмористические, интервью и т.д.). Конечно же для старта написания интернет ресурса требуются хотя бы базовые знания программирования.  
Именно вам выпала возможность продемонстрировать их, написав небольшой набор классов, которые будут выполнять похожий функционал на сайте.   
Всего будет 3 класса: **UrTube, Video, User.**

**Общее ТЗ:**   
Реализовать классы для взаимодействия с платформой, каждый из которых будет содержать методы добавления видео, авторизации и регистрации пользователя и т.д.

**Подробное ТЗ:**  
Каждый объект класса **User** должен обладать следующими атрибутами и методами:
* Атрибуты: **nickname**(имя пользователя, строка), **password**(в хэшированном виде, число), **age**(возраст, число)

Каждый объект класса **Video** должен обладать следующими атрибутами и методами:
* Атрибуты: **title**(заголовок, строка), **duration**(продолжительность, секунды), **time_now**(секунда остановки (изначально 0)), **adult_mode**(ограничение по возрасту, **bool** (**False** по умолчанию))

Каждый объект класса **UrTube** должен обладать следующими атрибутами и методами:
1. Атрибуты: **users**(список объектов User), **videos**(список объектов Video), **current_user**(текущий пользователь, User)
2. Метод **log_in**, который принимает на вход аргументы: **nickname**, **password** и пытается найти пользователя в **users** с такими же логином и паролем. Если такой пользователь существует, то **current_user** меняется на найденного. Помните, что **password** передаётся в виде строки, а сравнивается по хэшу.
3. Метод **register**, который принимает три аргумента: **nickname, password, age,** и добавляет пользователя в список, если пользователя не существует (с таким же **nickname**). Если существует, выводит на экран: "Пользователь {nickname} уже существует". После регистрации, вход выполняется автоматически.
4. Метод **log_out** для сброса текущего пользователя на **None**.
5. Метод **add**, который принимает неограниченное кол-во объектов класса **Video** и все добавляет в **videos**, если с таким же названием видео ещё не существует. В противном случае ничего не происходит.
6. Метод **get_videos**, который принимает поисковое слово и возвращает список названий всех видео, содержащих поисковое слово. Следует учесть, что слово 'UrbaN' присутствует в строке **'Urban the best'** (не учитывать регистр).
7. Метод **watch_video**, который принимает название фильма, если не находит точного совпадения(вплоть до пробела), то ничего не воспроизводится, если же находит - ведётся отчёт в консоль на какой секунде ведётся просмотр. После текущее время просмотра данного видео сбрасывается.

Для метода **watch_video** так же учитывайте следующие особенности:
1. Для паузы между выводами секунд воспроизведения можно использовать функцию **sleep** из модуля **time**.
2. Воспроизводить видео можно только тогда, когда пользователь вошёл в **UrTube**. В противном случае выводить в консоль надпись: "Войдите в аккаунт, чтобы смотреть видео"
3. Если видео найдено, следует учесть, что пользователю может быть отказано в просмотре, т.к. есть ограничения 18+. Должно выводиться сообщение: "Вам нет 18 лет, пожалуйста покиньте страницу"
4. После воспроизведения нужно выводить: "Конец видео"

Примечания:
* Не забывайте для удобства использовать **dunder**(магические) методы: **\_\_str__, \_\_repr__, \_\_contains__, \_\_eq__** и др. (повторить можно здесь)
* Чтобы не запутаться, рекомендуется после реализации каждого метода проверять как он работает, тестировать разные вариации.  