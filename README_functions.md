# Urban-Homework
My homeworks on Urban University learning
## Задача 1 (Task 1)
Напишите функцию высшего порядка, которая получает в качестве аргумента две функции первого порядка:
* Функцию для преобразования текста сообщения в верхний регистр.
* Функцию для преобразования текста сообщения в нижний регистр.
___

## Задача 2 (Task 2)
Часто при разработке и работе с рассылками писем (e-mail) они отправляются от одного и того же пользователя(администрации или службы поддержки). Тем не менее должна быть возможность сменить его в редких случаях. \
Создайте функцию **send_email**, которая принимает 2 обычных аргумента: сообщение и получатель и 1 обязательно именованный аргумент со значением по умолчанию - отправитель.\
Внутри функции реализовать следующую логику:
* Проверка на корректность e-mail отправителя и получателя.
* Проверка на отправку самому себе.
* Проверка на отправителя по умолчанию.
#### Пункты задачи:
1. Создайте функцию **send_email**, которая принимает 2 обычных аргумента: **message** (сообщение), **recipient** (получатель) и 1 обязательно именованный аргумент со значением по умолчанию **sender = "university.help@gmail.com"**.
2. Если строки **recipient** и **sender** не содержит **"@"** или не оканчивается на **".com"**, **".ru"**, **".net"**, то вывести на экран(в консоль) строку: "_Невозможно отправить письмо с адреса_ <**sender**> на адрес <**recipient**>".
3. Если же **sender** и **recipient** совпадают, то вывести "_Нельзя отправить письмо самому себе!_"
4. Если же отправитель по умолчанию - **university.help@gmail.com**, то вывести сообщение: "_Письмо успешно отправлено с адреса_ <**sender**> _на адрес_ <**recipient**>."
5. В противном случае вывести сообщение: "_НЕСТАНДАРТНЫЙ ОТПРАВИТЕЛЬ! Письмо отправлено с адреса_ <**sender**> _на адрес_ <**recipient**>."
6. За один вызов функции выводится **только одно** и перечисленных уведомлений! Проверки перечислены по мере выполнения.
___

## Задача 3 (Task 3) 
### Фукнции. Запаковка и распаковка параметров
Задача "Распаковка":\
**Функция с параметрами по умолчанию:**
1. Создайте функцию **print_params**(a = 1, b = 'строка', c = True), которая принимает три параметра со значениями по умолчанию (например сейчас это: **1, 'строка', True**).
2. Функция должна выводить эти параметры.
3. Вызовите функцию **print_params** с разным количеством аргументов, включая вызов без аргументов.
4. Проверьте, работают ли вызовы **print_params**(b = 25) **print_params**(c = [1,2,3])

**Распаковка параметров:**

1. Создайте список **values_list** с тремя элементами разных типов.
2. Создайте словарь **values_dict** с тремя ключами, соответствующими параметрам функции **print_params**, и значениями разных типов.
3. Передайте **values_list** и **values_dict** в функцию **print_params**, используя распаковку параметров (* для списка и ** для словаря).

**Распаковка + отдельные параметры:**

1. Создайте список **values_list_2** с двумя элементами разных типов
2. Проверьте, работает ли **print_params**(*values_list_2, 42)

**Пример результата выполнения программы:**  
Исходный код:
> values_list_2 = [54.32, 'Строка' ]\
>print_params(*values_list_2, 42) 
> 
Вывод на консоль:
>54.32 'Строка' 42
___

## Задача 4 (Task 4)
**Задача "Однокоренные":**\
Напишите функцию **single_root_words**, которая принимает одно обязательное слово в 
параметр **root_word**, а далее неограниченную последовательность в 
параметр *other_words.

Функция должна составить новый список **same_words** только из тех слов списка **other_words**, которые содержат **root_word** или наоборот **root_word** содержит одно из этих слов. После вернуть список **same_words** в качестве результата своей работы.

**Пункты задачи:**\
1. Объявите функцию **single_root_words** и напишите в ней параметры **root_word** и ***other_words**.
2. Создайте внутри функции пустой список **same_words**, который пополнится нужными словами.
3. При помощи цикла **for** переберите предполагаемо подходящие слова.
4. Пропишите корректное относительно задачи условие, при котором добавляются слова в результирующий список **same_words**.
5. После цикла верните образованный функцией список same_words.
6. Вызовите функцию **single_root_words** и выведете на экран(консоль) возвращённое ей значение.
7. Пример результата выполнения программы:

  **Исходный код:**  
> result1 = single_root_words('rich', 'richiest', 'orichalcum', 'cheers', 'richies')  
result2 = single_root_words('Disablement', 'Able', 'Mable', 'Disable', 'Bagel')  
print(result1)  
print(result2)

  **Вывод на консоль:**
> ['richiest', 'orichalcum', 'richies']  
['Able', 'Disable']

**Примечания:**
При проверке наличия одного слова в составе другого стоит учесть, что регистр символов не должен влиять ни на что. (**'Disablement' - 'Able'**) (**'Able', 'able', 'AbLe'** - все подходят)
___

<img src="https://mdg.imgix.net/assets/images/san-juan-mountains.jpg" width="400" height="300">

___
## Задача 5 (Task 5) 
### "Раз, два, три, четыре, пять .... Это не всё?":
Наши студенты, без исключения, - очень умные ребята. Настолько умные, 
что иногда по утру сами путаются в том, что намудрили вчера вечером.  
Один из таких учеников уснул на клавиатуре в процессе упорной учёбы 
(ещё и трудолюбивые). Тем не менее, даже после сна, его код остался рабочим и 
выглядел следующим образом:  
> **data_structure = [  
  [1, 2, 3],  
  {'a': 4, 'b': 5},  
  (6, {'cube': 7, 'drum': 8}),  
  "Hello",  
  ((), [{(2, 'Urban', ('Urban2', 35))}])  
]**

Увидев это студент задался вопросом: "А есть ли универсальное решение для 
подсчёта суммы всех чисел и длин всех строк?"  
Да, выглядит страшно, да и обращаться нужно к каждой внутренней структуре 
(списку, словарю и т.д.) по-разному.  
Ученику пришлось каждый раз использовать индексацию и обращение по 
ключам - универсального решения для таких структур он не нашёл.  

**Помогите сокурснику осуществить его задумку.**  
Что должно быть подсчитано:  
* Все числа (не важно, являются они ключами или значениям или ещё чем-то).
* Размеры всех строк (не важно, являются они ключами или значениям или ещё чем-то)  

Для примера, указанного выше, расчёт вёлся следующим образом:  
1 + 2 + 3 + len('a') + 4 + len('b') + 5 + 6 + len('cube') + 7 + .... + 35 = 99
___

## Задача 6 (Task 6) Urban
### "А как делить?":

В школе нам говорили, что на 0 делить нельзя. Высшая же математика опровергает это и 
говорит, что результат при делении на 0 будет стремиться к бесконечности.  
Давайте реализуем оба способа, чтобы у вас всегда был выбор!  
Создайте модули **fake_math** и **true_math** в которых создайте функции отвечающие 
за деление, но разными способами.  
В **fake_math** создайте функцию **divide**, которая принимает два параметра **first** 
и **second**. Функция должна возвращать результат деления **first** на **second**, но 
когда в second записан 0 - возвращать строку **'Ошибка'**.  
В **true_math** создайте функцию **divide**, которая принимает два параметра **first** 
и **second**. 
Функция должна возвращать результат деления **first** на **second**, но когда в 
second записан 0 - возвращать **бесконечность**.  
Бесконечность можно импортировать из встроенной библиотеки **math** (_from math import
inf_)  
**Пункты задачи:**
* Создайте модули **fake_math** и **true_math**.
* Напишите функции **divide** в обоих методах. Разница между этими функциями - 
возвращаемое значение.
* Создайте модуль **module_4_1** (если ещё не создан), импортируйте в него 
функции **divide** из модулей **fake_math** и **true_math**, назвав их разными 
именами на своё усмотрение, чтобы не было конфликтов имён, при помощи оператора **as**.
* Запустите эти функции в модуле **module_4_1**, передав первым аргументом 
произвольное число отличное от 0, вторым аргументом - 0
* Выведи результаты вызовов этих функций на экран(в консоль).
___

## Задача 7 (Task 7) Urban
### "Developer - не только разработчик":  
Файл **module_5_1.py**   
Реализуйте класс **House**, объекты которого будут создаваться следующим образом:
* House('ЖК Эльбрус', 30)      

Объект этого класса должен обладать следующими атрибутами:
* **self.name** - имя, **self.number_of_floors** - кол-во этажей

Также должен обладать методом **go_to(new_floor)**, где **new_floor** - номер этажа(int), на который нужно приехать.  
Метод **go_to** выводит на экран(в консоль) значения от 1 до **new_floor**(включительно).  
Если же **new_floor** больше чем **self.number_of_floors** или меньше **1**, то вывести строку **"Такого этажа не существует"**.

Пункты задачи:
* Создайте класс House.
* Внутри класса House определите метод  **\_\_init__**, в который передадите название и кол-во этажей.
* Внутри метода **\_\_init__** создайте атрибуты объекта **self.name** и **self.number_of_floors**, присвойте им переданные значения.
* Создайте метод **go_to** с параметром **new_floor** и напишите логику внутри него на основе описания задачи.
* Создайте объект класса **House** с произвольным названием и количеством этажей.
* Вызовите метод **go_to** у этого объекта с произвольным числом.

## Задача 8 (Task 8) Urban HARD
**Задание "Свой YouTube":**  
Университет Urban подумывает о создании своей платформы, где будут размещаться дополнительные полезные ролики на тему IT (юмористические, интервью и т.д.). Конечно же для старта написания интернет ресурса требуются хотя бы базовые знания программирования.  
Именно вам выпала возможность продемонстрировать их, написав небольшой набор классов, которые будут выполнять похожий функционал на сайте.   
Всего будет 3 класса: **UrTube, Video, User.**

**Общее ТЗ:**   
Реализовать классы для взаимодействия с платформой, каждый из которых будет содержать методы добавления видео, авторизации и регистрации пользователя и т.д.

**Подробное ТЗ:**  
Каждый объект класса **User** должен обладать следующими атрибутами и методами:
* Атрибуты: **nickname**(имя пользователя, строка), **password**(в хэшированном виде, число), **age**(возраст, число)

Каждый объект класса **Video** должен обладать следующими атрибутами и методами:
* Атрибуты: **title**(заголовок, строка), **duration**(продолжительность, секунды), **time_now**(секунда остановки (изначально 0)), **adult_mode**(ограничение по возрасту, **bool** (**False** по умолчанию))

Каждый объект класса **UrTube** должен обладать следующими атрибутами и методами:
1. Атрибуты: **users**(список объектов User), **videos**(список объектов Video), **current_user**(текущий пользователь, User)
2. Метод **log_in**, который принимает на вход аргументы: **nickname**, **password** и пытается найти пользователя в **users** с такими же логином и паролем. Если такой пользователь существует, то **current_user** меняется на найденного. Помните, что **password** передаётся в виде строки, а сравнивается по хэшу.
3. Метод **register**, который принимает три аргумента: **nickname, password, age,** и добавляет пользователя в список, если пользователя не существует (с таким же **nickname**). Если существует, выводит на экран: "Пользователь {nickname} уже существует". После регистрации, вход выполняется автоматически.
4. Метод **log_out** для сброса текущего пользователя на **None**.
5. Метод **add**, который принимает неограниченное кол-во объектов класса **Video** и все добавляет в **videos**, если с таким же названием видео ещё не существует. В противном случае ничего не происходит.
6. Метод **get_videos**, который принимает поисковое слово и возвращает список названий всех видео, содержащих поисковое слово. Следует учесть, что слово 'UrbaN' присутствует в строке **'Urban the best'** (не учитывать регистр).
7. Метод **watch_video**, который принимает название фильма, если не находит точного совпадения(вплоть до пробела), то ничего не воспроизводится, если же находит - ведётся отчёт в консоль на какой секунде ведётся просмотр. После текущее время просмотра данного видео сбрасывается.

Для метода **watch_video** так же учитывайте следующие особенности:
1. Для паузы между выводами секунд воспроизведения можно использовать функцию **sleep** из модуля **time**.
2. Воспроизводить видео можно только тогда, когда пользователь вошёл в **UrTube**. В противном случае выводить в консоль надпись: "Войдите в аккаунт, чтобы смотреть видео"
3. Если видео найдено, следует учесть, что пользователю может быть отказано в просмотре, т.к. есть ограничения 18+. Должно выводиться сообщение: "Вам нет 18 лет, пожалуйста покиньте страницу"
4. После воспроизведения нужно выводить: "Конец видео"

Примечания:
* Не забывайте для удобства использовать **dunder**(магические) методы: **\_\_str__, \_\_repr__, \_\_contains__, \_\_eq__** и др. (повторить можно здесь)
* Чтобы не запутаться, рекомендуется после реализации каждого метода проверять как он работает, тестировать разные вариации.

# Наследование классов
## Задача 9 (Task 6.1) Urban 
**Задача "Съедобное, несъедобное":**
Разнообразие животного мира давно будоражит умы человечества. Царства, классы, виды... Почему бы и нам не попробовать выстроить что-то подобное используя наследования классов?  
Необходимо описать пример иерархии животного мира, используя классы и принцип наследования.  
**Создайте:**
* 2 класса родителя: **Animal, Plant**

Для класса **Animal** атрибуты **alive = True(живой)** и **fed = False(накормленный)**, **name** - индивидуальное название каждого животного.   
Для класса **Plant** атрибут **edible = False(съедобность)**, **name** - индивидуальное название каждого растения

* 4 класса наследника:

* **Mammal, Predator** для **Animal**.
* **Flower, Fruit** для **Plant**.

У каждого из объектов класса **Mammal** и **Predator** должны быть атрибуты и методы:
* **eat(self, food)** - метод, где **food** - это параметр, принимающий объекты классов растений.

Метод **eat** должен работать следующим образом:
* Если переданное растение (**food**) съедобное - выводит на экран **"<self.name> съел <food.name>"**, меняется атрибут **fed** на **True**.
* Если переданное растение (**food**) не съедобное - выводит на экран **"<self.name> не стал есть <food.name>"**, меняется атрибут **alive** на **False**.

Т.е если животному дать съедобное растение, то животное насытится, если не съедобное - погибнет.  
У каждого объекта **Fruit** должен быть атрибут **edible = True** (переопределить при наследовании).  
Создайте объекты классов и проделайте действия затронутые в примере результата работы программы.  
Пункты задачи:
1. Создайте классы Animal и Plant с соответствующими атрибутами и методами
2. Создайте(+унаследуйте) классы Mammal, Predator, Flower, Fruit с соответствующими атрибутами и методами. При необходимости переопределите значения атрибутов.
3. Создайте объекты этих классов.

## Задача 10 (Task 6.2) Urban 
**Задача "Изменять нельзя получать":**

В этой задаче мы реализуем классы транспорта, в которых нельзя будет просто так 
поменять цвет, мощность двигателя и прочие свойства, т.к. в реальной жизни это 
чаще всего делается не владельцем, а в специальных сервисах. Да, узнать значения 
этих свойств мы сможем, но вот изменить - нет.  
Вам необходимо создать 2 класса: **Vehicle** и **Sedan**, где **Vehicle** - это 
любой транспорт, а **Sedan(седан)** - наследник класса **Vehicle**.   
**I.** Каждый объект **Vehicle** должен содержать следующие атрибуты объекта:
1. Атрибут **owner(str)** - владелец транспорта. (владелец может меняться)
2. Атрибут **__model(str)** - модель (марка) транспорта. (мы не можем менять название модели)
3. Атрибут **__engine_power(int**) - мощность двигателя. (мы не можем менять мощность двигателя самостоятельно)
4. Атрибут **__color(str)** - название цвета. (мы не можем менять цвет автомобиля своими руками)

А так же атрибут класса:  
1. Атрибут класса **__COLOR_VARIANTS**, в который записан список допустимых цветов для окрашивания. (Цвета написать свои)

Каждый объект **Vehicle** должен содержать следующий методы:
1. Метод **get_model** - возвращает строку: *\"Модель: <название модели транспорта>"*
2. Метод **get_horsepower** - возвращает строку: *\"Мощность двигателя: <мощность>"*
3. Метод **get_color** - возвращает строку: *\"Цвет: <цвет транспорта>"*
4. Метод **print_info** - распечатывает результаты методов (в том же порядке): **get_model, get_horsepower, get_color**; а так же владельца в конце в формате *\"Владелец: <имя>"*
5. Метод **set_color** - принимает аргумент **new_color(str)**, меняет цвет **__color** на **new_color**, если он есть в списке **__COLOR_VARIANTS**, в противном случае выводит на экран надпись: *\"Нельзя сменить цвет на <новый цвет>".*

Взаимосвязь методов и скрытых атрибутов:
* Методы **get_model, get_horsepower, get_color** находятся в одном классе с соответствующими им атрибутами: **__model, __engine_power, __color**. Поэтому атрибуты будут доступны для методов.
* Атрибут класса **__COLOR_VARIANTS** можно получить обращаясь к нему через объект**(self)**.
* Проверка в **__COLOR_VARIANTS** происходит не учитывая регистр ('BLACK' ~ 'black').

**II.** Класс **Sedan** наследуется от класса **Vehicle**, а так же содержит следующие атрибуты:
* Атрибут **__PASSENGERS_LIMIT = 5** (в седан может поместиться только 5 пассажиров)

Пункты задачи:
* Создайте классы **Vehicle** и **Sedan**.
* Напишите соответствующие свойства в обоих классах.
* Не забудьте сделать **Sedan** наследником класса **Vehicle**.
* Создайте объект класса **Sedan** и проверьте, как работают все его методы, взяты из класса **Vehicle**.

## Задача 11 (Task 6.3) Urban 
**Задача "Ошибка эволюции":**

Замечали, что некоторые животные в нашем мире обладают странными и, порой, несовместимыми друг с другом свойствами? Например, утконос... Вроде есть клюв, но не птица. Вроде милый, а есть шипы на задних лапах. А ещё он откладывает яйца... Опустим факт о том, что они потеют молоком и попробуем не эволюционным способом создать нашего утконоса.  

Необходимо написать 5 классов:
* **Animal** - класс описывающий животных.

**Класс** обладает следующими атрибутами:
* **live = True**
* **sound = None** - звук (изначально отсутствует)
* **_DEGREE_OF_DANGER = 0** - степень опасности существа

**Объект этого класса** обладает следующими атрибутами:
* **_cords = [0, 0, 0]** - координаты в пространстве.
* **speed =** ... - скорость передвижения существа (определяется при создании объекта)

И методами:
* **move(self, dx, dy, dz)**, который должен менять соответствующие кооординаты в **_cords** на dx, dy и dz в том же порядке, где множетелем будет являтся **speed**. 
Если при попытке изменения координаты z в **_cords** значение будет меньше 0, то выводить сообщение *\"It's too deep, i can't dive :("* , при этом изменения не вносяться.
* **get_cords(self)**, который выводит координаты в формате: "X: <координаты по x>, Y: <координаты по y>, Z: <координаты по z>"
* **attack(self)**, который выводит *\"Sorry, i'm peaceful :)"*, если степень опасности меньше 5 и *\"Be careful, i'm attacking you 0_0"* , если больше.
* **speak(self)**, который выводит строку со звуком **sound**.

**Bird** - класс описывающий птиц. Наследуется от **Animal**.  
Должен обладать атрибутом:
* **beak = True** - наличие клюва

И методом:
* **lay_eggs(self)**, который выводит строку *\"Here are(is) <случайное число от 1 до 4> eggs for you"*

**AquaticAnimal** - класс описывающий плавающего животного. Наследуется от **Animal**.  
В этом классе атрибут **_DEGREE_OF_DANGER = 3**.  
Должен обладать методом:
* **dive_in(self, dz)** - где dz изменение координаты z в **_cords**. Должен изменять в отрицательную сторону координату z уменьшенную в 2 раза с учётом скорости. С каким бы знаком не был передан параметр dz, внутри метода используйте его значение по модулю (функция abs).

**PoisonousAnimal** - класс описывающий ядовитых животных. Наследуется от **Animal**.  
В этом классе атрибут **_DEGREE_OF_DANGER = 8**.

**Duckbill** - класс описывающий утконоса. Наследуется от классов **Bird, AquaticAnimal, PoisonousAnimal**. Порядок наследования определите сами, опираясь на ниже приведённые примеры выполнения кода.  
Объект этого класса должен обладать одним дополнительным атрибутом:
* **sound = "Click-click-click"** - звук, который издаёт утконос

По итогу мы должны получить живого утконоса с клювом, атакующего и издающего странные звуки.
После чего утконос совершает манёвры и ныряет.  
Теперь утконос в безопасности, он откладывает яйца для будущего потомства.

Примечания:
1. Будьте внимательней, когда вызываете методы классов родителей в классе наследнике при множественном наследовании: при обращении через super() методы будут искаться сначала в первом, потом во втором и т.д. классах по mro().
2. При определении порядка наследования обратите внимание на то, что утконос атакует "Be careful, i'm attacking you 0_0"

## Задача 12 (Task 6.4 hard) Urban 
**Задание "Они все так похожи":**

2D? 3D? Даже 4D?.... Настолько глубоко мы заходить конечно же не будем, 4D подождёт, но вот с двумерными и трёхмерными фигурами можем поэкспериментировать.
Вы когда-нибудь задумывались как устроены графические библиотеки для языков программирования?  
Безусловно, там выполняются огромные расчёты при помощи вашей видеокарты, но... Что лежит в основе удобного использования таких объектов?  
По названию задачи можно понять, что все геометрические фигуры обладают схожими свойствами, такими как: длины сторон, цвет и др.  
Давайте попробуем реализовать простейшие классы для некоторых таких фигур и при этом применить наследование (в будущем, изучая сторонние библиотеки, вы будете замечать схожие классы, уже написанные кем-то ранее):

**Общее ТЗ:**
* Реализовать классы **Figure**(родительский), **Circle, Triangle** и **Cube**, объекты которых будут обладать методами изменения размеров, цвета и т.д.

Многие атрибуты и методы должны быть инкапсулированны и для них должны быть написаны интерфейсы взаимодействия (методы) - геттеры и сеттеры.

Подробное ТЗ:  

Атрибуты **класса Figure**:
* **sides_count = 0**

Каждый объект класса **Figure** должен обладать следующими атрибутами:
1. Атрибуты(инкапсулированные): **__sides**(список сторон (целые числа)), **__color**(список цветов в формате RGB)
2. Атрибуты(публичные): **filled**(закрашенный, bool)

И методами:
1. Метод **get_color**, возвращает список RGB цветов.
2. Метод **__is_valid_color** - служебный, принимает параметры r, g, b, который проверяет корректность переданных значений перед установкой нового цвета. Корректный цвет: все значения r, g и b - целые числа в диапазоне от 0 до 255 (включительно).
4. Метод **set_color** принимает параметры r, g, b - числа и изменяет атрибут **__color** на соответствующие значения, предварительно проверив их на корректность. Если введены некорректные данные, то цвет остаётся прежним.
5. Метод **__is_valid_sides** - служебный, принимает неограниченное кол-во сторон, возвращает **True** если все стороны целые положительные числа и кол-во новых сторон совпадает с текущим, **False** - во всех остальных случаях.
6. Метод **get_sides** должен возвращать значение я атрибута **__sides**.
7. Метод **__len__** должен возвращать периметр фигуры.
8. Метод **set_sides(self, *new_sides)** должен принимать новые стороны, если их количество не равно **sides_count**, то не изменять, в противном случае - менять.

Атрибуты **класса Circle**:
* **sides_count = 1**

Каждый объект класса **Circle** должен обладать следующими атрибутами и методами:
1. Все атрибуты и методы класса **Figure**
2. Атрибут **__radius**, рассчитать исходя из длины окружности (одной единственной стороны).
3. Метод **get_square** возвращает площадь круга (можно рассчитать как через длину, так и через радиус).

Атрибуты **класса Triangle**:
* **sides_count = 3**

Каждый объект класса **Triangle** должен обладать следующими атрибутами и методами:
1. Все атрибуты и методы класса **Figure**
2. Метод **get_square** возвращает площадь треугольника. (можно рассчитать по формуле Герона)

Атрибуты **класса Cube**:
* **sides_count = 12**

Каждый объект класса **Cube** должен обладать следующими атрибутами и методами:
1. Все атрибуты и методы класса **Figure**.
2. Переопределить **__sides** сделав список из 12 одинаковы сторон (передаётся 1 сторона)
3. Метод **get_volume**, возвращает объём куба.

**ВАЖНО!**  
При создании объектов делайте проверку на количество переданных сторон, если сторон не ровно sides_count, то создать массив с единичными сторонами и в том кол-ве, которое требует фигура.

**Примеры.**  
Пример 1: Circle((200, 200, 100), 10, 15, 6), т.к. сторона у круга всего 1, то его стороны будут - [1]

Пример 2: Triangle((200, 200, 100), 10, 6), т.к. сторон у треугольника 3, то его стороны будут - [1, 1, 1]

Пример 3: Cube((200, 200, 100), 9), т.к. сторон(рёбер) у куба - 12, то его стороны будут - [9, 9, 9, ....., 9] (12)

Пример 4: Cube((200, 200, 100), 9, 12), т.к. сторон(рёбер) у куба - 12, то его стороны будут - [1, 1, 1, ....., 1]

**Примечания (рекомендации)**:
1. Рекомендуется сделать дополнительные (свои проверки) работы методов объектов каждого класса.
2. Делайте каждый класс и метод последовательно и проверяйте работу каждой части отдельно.
3. Для проверки принадлежности к типу рекомендуется использовать функцию **isinstance**.
4. Помните, служебные инкапсулированные методы можно и нужно использовать только внутри текущего класса.
5. Вам не запрещается вводить дополнительные атрибуты и методы, **творите, но не переборщите!**